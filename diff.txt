diff --git a/bluep/__init__.py b/bluep/__init__.py
index b5f8ee6..8b0bd7e 100644
--- a/bluep/__init__.py
+++ b/bluep/__init__.py
@@ -1,21 +1,24 @@
-from .auth import TOTPAuth, SessionManager
+"""Bluep collaborative text editor package.
+
+This package provides a secure real-time collaborative text editor with TOTP
+authentication and a blue theme. It enables multiple users to connect and edit
+text simultaneously through their browsers.
+"""
+from .auth import TOTPAuth
+from .cert_generator import generate_ssl_certs
 from .config import Settings
 from .models import WebSocketMessage
 from .middleware import RateLimitMiddleware
 from .secure_config import SecureConfig
-from .session_manager import SessionData, SessionManager
+from .session_manager import SessionData
 from .websocket_manager import WebSocketManager
-from .ssl import generate_ssl_certs
 
 __version__ = "0.4.0"
-
 __all__ = [
     "RateLimitMiddleware",
     "SessionData",
-    "SessionManager",
     "Settings",
     "SecureConfig",
-    "SessionManager",
     "TOTPAuth",
     "WebSocketManager",
     "WebSocketMessage",
diff --git a/bluep/bluep.py b/bluep/bluep.py
index 3f874d7..5b15b7c 100755
--- a/bluep/bluep.py
+++ b/bluep/bluep.py
@@ -18,18 +18,17 @@ from PIL import Image
 import qrcode
 import uvicorn
 
-from bluep.auth import TOTPAuth
-from bluep.config import Settings
-from bluep.models import WebSocketMessage
-from bluep.middleware import configure_security
-from bluep.websocket_manager import WebSocketManager
+from .auth import TOTPAuth
+from .config import Settings
+from .models import WebSocketMessage
+from .middleware import configure_security
+from .websocket_manager import WebSocketManager
 
 # Initialize core application components
 templates = Jinja2Templates(directory="templates")
 settings = Settings()
 ws_manager = WebSocketManager()
 
-
 class BlueApp:
     """Application context manager for bluep."""
 
@@ -48,73 +47,6 @@ class BlueApp:
         self.app.get("/favicon.png")(self.favicon)
         self.app.websocket("/ws")(self.websocket_endpoint)
 
-    async def qr_raw(self) -> Response:
-        """Generate and serve the TOTP QR code.
-
-        Returns:
-            Response: PNG image of the QR code
-        """
-        qr = qrcode.QRCode(version=1, box_size=10, border=5)
-        qr.add_data(self.auth.totp.provisioning_uri("Bluep Room", issuer_name="Bluep"))
-        qr.make(fit=True)
-
-        img = qr.make_image(fill_color="black", back_color="white")
-        img_bytes = BytesIO()
-        img.save(img_bytes, format="PNG")
-        img_bytes.seek(0)
-
-        return Response(content=img_bytes.getvalue(), media_type="image/png")
-
-    async def setup(self, request: Request):
-        """Serve the TOTP setup page.
-
-        Args:
-            request: FastAPI request object
-
-        Returns:
-            TemplateResponse: Rendered setup page
-        """
-        return templates.TemplateResponse(
-            "setup.html",
-            {
-                "request": request,
-                "qr_code": self.auth.qr_base64,
-                "secret_key": self.auth.secret_key,
-                "current_token": self.auth.totp.now(),
-            },
-        )
-
-    async def get(
-        self,
-        request: Request,
-        response: Response,
-        key: Optional[str] = None
-    ):
-        """Handle main page access and authentication.
-
-        Args:
-            request: FastAPI request object
-            response: FastAPI response object
-            key: Optional TOTP key for authentication
-
-        Returns:
-            Response: Either editor page or login redirect
-        """
-        if not key:
-            return RedirectResponse(url="/login")
-
-        await self.auth.verify_and_create_session(key, request, response)
-
-        return templates.TemplateResponse(
-            "editor.html",
-            {
-                "request": request,
-                "host_ip": settings.host_ip,
-                "key": key,
-                "blue": settings.blue_color,
-            },
-        )
-
     async def websocket_endpoint(
         self,
         websocket: WebSocket,
diff --git a/bluep/config.py b/bluep/config.py
index f0c8813..e983ca9 100644
--- a/bluep/config.py
+++ b/bluep/config.py
@@ -6,7 +6,7 @@ SSL certificates, and appearance customization.
 import socket
 from pydantic import BaseModel, model_validator
 
-from bluep.ssl import generate_ssl_certs
+from bluep.cert_generator import generate_ssl_certs
 
 class Settings(BaseModel):
     """Application settings and configuration.
diff --git a/bluep/middleware.py b/bluep/middleware.py
index 4c322a0..8a4b953 100644
--- a/bluep/middleware.py
+++ b/bluep/middleware.py
@@ -1,14 +1,24 @@
-# middleware.py
+"""Middleware components for security and rate limiting.
+
+This module provides middleware components for the bluep application including
+CORS configuration, trusted hosts, rate limiting, and security headers.
+"""
+import time
+from collections import defaultdict
+from typing import DefaultDict, List
+
 from fastapi import FastAPI, Request, Response
 from fastapi.middleware.cors import CORSMiddleware
 from fastapi.middleware.trustedhost import TrustedHostMiddleware
 from starlette.middleware.base import BaseHTTPMiddleware
-import time
-from collections import defaultdict
-from typing import DefaultDict, List
 
 
 def configure_security(app: FastAPI) -> None:
+    """Configure security middleware for the application.
+
+    Args:
+        app: FastAPI application instance
+    """
     app.add_middleware(
         CORSMiddleware,
         allow_origins=["*"],
@@ -18,7 +28,6 @@ def configure_security(app: FastAPI) -> None:
     )
 
     app.add_middleware(TrustedHostMiddleware, allowed_hosts=["*"])
-
     app.add_middleware(RateLimitMiddleware, rate_limit=100, window=60)
 
     @app.middleware("http")
@@ -35,13 +44,34 @@ def configure_security(app: FastAPI) -> None:
 
 
 class RateLimitMiddleware(BaseHTTPMiddleware):
+    """Rate limiting middleware for request throttling.
+
+    Implements a sliding window rate limiter to prevent abuse.
+    """
+
     def __init__(self, app: FastAPI, rate_limit: int = 100, window: int = 60):
+        """Initialize rate limiter.
+
+        Args:
+            app: FastAPI application instance
+            rate_limit: Maximum requests per window
+            window: Time window in seconds
+        """
         super().__init__(app)
         self.rate_limit = rate_limit
         self.window = window
         self.requests: DefaultDict[str, List[float]] = defaultdict(list)
 
     async def dispatch(self, request: Request, call_next):
+        """Process request and apply rate limiting.
+
+        Args:
+            request: Incoming request
+            call_next: Next middleware/handler
+
+        Returns:
+            Response: Response with rate limit status
+        """
         client_host = request.client.host if request.client else "0.0.0.0"
         current_time = time.time()
 
diff --git a/bluep/secure_config.py b/bluep/secure_config.py
index dec91a3..505ffb9 100644
--- a/bluep/secure_config.py
+++ b/bluep/secure_config.py
@@ -1,14 +1,32 @@
-from cryptography.fernet import Fernet
-from pathlib import Path
-import json
+"""Secure configuration management for bluep.
+
+This module handles secure storage and retrieval of configuration data,
+particularly TOTP secrets, using machine-specific encryption.
+"""
 import base64
+import json
 import os
 import platform
 import uuid
+from pathlib import Path
+from typing import Optional
+
+from cryptography.fernet import Fernet
 
 
 class SecureConfig:
-    def __init__(self, config_path=None):
+    """Secure configuration manager using machine-specific encryption.
+
+    Handles encrypted storage and retrieval of sensitive configuration data,
+    using machine-specific identifiers for key generation.
+    """
+
+    def __init__(self, config_path: Optional[Path] = None) -> None:
+        """Initialize secure configuration manager.
+
+        Args:
+            config_path: Optional custom path for config file
+        """
         if config_path is None:
             config_path = self._get_default_config_path()
             print(f"Config path: {config_path}")
@@ -19,43 +37,64 @@ class SecureConfig:
         self.key = base64.urlsafe_b64encode(machine_id[:32].encode().ljust(32)[:32])
         self.fernet = Fernet(self.key)
 
-    def _get_default_config_path(self):
+    def _get_default_config_path(self) -> Path:
+        """Get the default platform-specific configuration path.
+
+        Returns:
+            Path: Default configuration file path
+        """
         system = platform.system()
         if system == "Windows":
             return Path(os.environ["LOCALAPPDATA"]) / "bluep" / "config.enc"
-        elif system == "Darwin":  # macOS
+        if system == "Darwin":  # macOS
             return (
                 Path.home() / "Library" / "Application Support" / "bluep" / "config.enc"
             )
         return Path.home() / ".bluep" / "config.enc"  # Linux/Unix
 
-    def _get_machine_id(self):
+    def _get_machine_id(self) -> str:
+        """Get unique machine identifier for encryption key generation.
+
+        Returns:
+            str: Machine-specific identifier
+        """
         system = platform.system()
         if system == "Windows":
-            return str(uuid.UUID(int=uuid.getnode()))  # Use MAC address
-        elif system == "Darwin":
-            # Use macOS system UUID
+            return str(uuid.UUID(int=uuid.getnode()))
+        if system == "Darwin":
             try:
                 return (
                     os.popen("ioreg -rd1 -c IOPlatformExpertDevice | grep UUID")
                     .read()
                     .split('"')[3]
                 )
-            except:
+            except Exception as e:
+                print(f"Error getting macOS UUID: {e}")
                 return str(uuid.UUID(int=uuid.getnode()))
+
         # Linux fallbacks
         for path in ["/etc/machine-id", "/var/lib/dbus/machine-id"]:
             if os.path.exists(path):
-                with open(path) as f:
+                with open(path, encoding='utf-8') as f:
                     return f.read().strip()
         return str(uuid.UUID(int=uuid.getnode()))
 
-    def save_secret(self, totp_secret):
+    def save_secret(self, totp_secret: str) -> None:
+        """Save TOTP secret to encrypted configuration.
+
+        Args:
+            totp_secret: TOTP secret to store
+        """
         config = {"totp_secret": totp_secret}
         encrypted = self.fernet.encrypt(json.dumps(config).encode())
         self.config_path.write_bytes(encrypted)
 
-    def load_secret(self):
+    def load_secret(self) -> Optional[str]:
+        """Load TOTP secret from encrypted configuration.
+
+        Returns:
+            Optional[str]: Stored TOTP secret if found
+        """
         if not self.config_path.exists():
             return None
         encrypted = self.config_path.read_bytes()
diff --git a/bluep/session_manager.py b/bluep/session_manager.py
index a1f4af4..dc79184 100644
--- a/bluep/session_manager.py
+++ b/bluep/session_manager.py
@@ -1,20 +1,47 @@
+"""Session management for bluep.
+
+This module handles user session creation, validation, and cleanup for
+authenticated users of the collaborative editor.
+"""
+from datetime import datetime, timedelta
+import secrets
+from typing import Dict, Optional
+
 from fastapi import Response
 from fastapi.security import APIKeyCookie
-import secrets
-from datetime import datetime, timedelta
-from typing import Optional, Literal, Dict
 
 from bluep.models import SessionData
 
 
 class SessionManager:
+    """Manages user sessions with secure cookie-based authentication.
+
+    Handles session lifecycle including creation, validation, and expiration
+    of user sessions with secure cookie storage.
+    """
+
     def __init__(self, cookie_name: str = "bluep_session", cookie_max_age: int = 3600):
+        """Initialize session manager.
+
+        Args:
+            cookie_name: Name for session cookie
+            cookie_max_age: Session lifetime in seconds
+        """
         self.sessions: Dict[str, SessionData] = {}
         self.cookie_name = cookie_name
         self.cookie_max_age = cookie_max_age
         self.cookie_security = APIKeyCookie(name=cookie_name, auto_error=False)
 
     def create_session(self, username: str, response: Response) -> str:
+        """Create new user session with secure cookie.
+
+        Args:
+            username: User identifier
+            response: FastAPI response for cookie setting
+
+        Returns:
+            str: New session identifier
+        """
         session_id = secrets.token_urlsafe(32)
         expiry = datetime.now() + timedelta(seconds=self.cookie_max_age)
 
@@ -34,6 +61,14 @@ class SessionManager:
         return session_id
 
     def get_session(self, session_id: str) -> Optional[SessionData]:
+        """Get session data if valid and not expired.
+
+        Args:
+            session_id: Session identifier to look up
+
+        Returns:
+            Optional[SessionData]: Session data if valid
+        """
         session = self.sessions.get(session_id)
         if not session:
             return None
@@ -43,14 +78,3 @@ class SessionManager:
             return None
 
         return session
-
-    def validate_totp_use(self, session_id: str, totp_code: str) -> bool:
-        session = self.get_session(session_id)
-        if not session:
-            return False
-
-        if session.last_totp_use == totp_code:
-            return False
-
-        session.last_totp_use = totp_code
-        return True
diff --git a/bluep/ssl.py b/bluep/ssl.py
deleted file mode 100644
index 6bd3e13..0000000
--- a/bluep/ssl.py
+++ /dev/null
@@ -1,47 +0,0 @@
-import datetime
-import os
-import ipaddress
-from pathlib import Path
-from cryptography import x509
-from cryptography.x509.oid import NameOID
-from cryptography.hazmat.primitives import hashes, serialization
-from cryptography.hazmat.primitives.asymmetric import rsa
-
-
-def generate_ssl_certs(cert_path: str = "cert.pem", key_path: str = "key.pem"):
-    if os.path.exists(cert_path) and os.path.exists(key_path):
-        return
-
-    private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
-
-    subject = issuer = x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, "localhost")])
-
-    cert = (
-        x509.CertificateBuilder()
-        .subject_name(subject)
-        .issuer_name(issuer)
-        .public_key(private_key.public_key())
-        .serial_number(x509.random_serial_number())
-        .not_valid_before(datetime.datetime.utcnow())
-        .not_valid_after(datetime.datetime.utcnow() + datetime.timedelta(days=365))
-        .add_extension(
-            x509.SubjectAlternativeName(
-                [
-                    x509.DNSName("localhost"),
-                    x509.IPAddress(ipaddress.ip_address("127.0.0.1")),
-                ]
-            ),
-            critical=False,
-        )
-        .sign(private_key, hashes.SHA256())
-    )
-
-    # Write cert and key
-    Path(cert_path).write_bytes(cert.public_bytes(serialization.Encoding.PEM))
-    Path(key_path).write_bytes(
-        private_key.private_bytes(
-            encoding=serialization.Encoding.PEM,
-            format=serialization.PrivateFormat.PKCS8,
-            encryption_algorithm=serialization.NoEncryption(),
-        )
-    )
