<!DOCTYPE html>
<html>
<head>
    <title>bluep (0)</title>
    <link rel="icon" type="image/png" href="/favicon.png?key={{key}}">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'; connect-src 'self' wss:; img-src 'self' data:">
    <style>
        body, html {
            margin: 0;
            padding: 8px;
            height: calc(100vh - 32px);
            width: calc(100vw - 32px);
            background: {{blue}};
            overflow: hidden;
        }
        #editor {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 16px;
            background-color: {{blue}};
            color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
            resize: none;
            box-sizing: border-box;
            position: relative;
        }
        #editor::before {
            content: "bluep";
            position: absolute;
            top: -0.5em;
            left: 3em;
            transform: translateX(-50%);
            background: {{blue}};
            padding: 0 10px;
            color: #fff;
        }
        #editor textarea {
            width: 100%;
            height: 100%;
            background-color: {{blue}};
            color: #fff;
            border: none;
            outline: none;
            resize: none;
            font-size: 16px;
            font-family: monospace;
            padding: 16px;
            box-sizing: border-box;
        }
    </style>
    <script src="/static/js/crypto-utils.js" integrity="sha384-{{js_integrity_hash}}" crossorigin="anonymous"></script>
</head>
<body>
    <div id="editor">
        <textarea autofocus></textarea>
    </div>
    <script>
        // Security: Verify the connection and check for tampering
        document.addEventListener('DOMContentLoaded', function() {
            // Verify certificate and detect tampering
            verifyConnection("{{cert_fingerprint}}");
            detectExtensionTampering({{script_length}});
            
            // Check security verification every minute
            setInterval(() => verifyConnection("{{cert_fingerprint}}"), 60000);
        });
        
        // Initialize main application after security checks
        (async function() {
            // First perform security key exchange
            const token = "{{token}}";
            let encryptionKey = null;
            
            try {
                // Use more secure key exchange
                await performKeyExchange(token);
                console.log("ECDH key exchange completed successfully");
            } catch (e) {
                console.warn("Using fallback encryption method:", e);
            }
            
            // Create WebSocket with auth key
            const wsUrl = `wss://${window.location.host}/ws?token=${token}`;
            let ws = new WebSocket(wsUrl);
            
            // Track connection state
            let isConnected = false;
            let reconnectAttempts = 0;
            const MAX_RECONNECT_ATTEMPTS = 5;
            const editor = document.querySelector('#editor textarea');
            let isReceiving = false;
            
            ws.onopen = async () => {
                isConnected = true;
                reconnectAttempts = 0;
                console.log('Connected to server');
    
                // Send initial message with encrypted content
                const encryptedData = await encryptText("bluep");
                ws.send(JSON.stringify({
                    type: "content",
                    data: encryptedData,
                    encrypted: true,
                    keyId: "latest" // Use the latest key from key exchange
                }));
            };
    
            ws.onclose = (event) => {
                console.log('WebSocket closed:', event.code, event.reason);
                isConnected = false;
                if (event.code === 403) {
                    handleTOTPExpiry();
                } else {
                    handleDisconnect();
                }
            };
    
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
    
            // Add message handler
            ws.onmessage = async (event) => {
                // Don't log sensitive data
                const msg = JSON.parse(event.data);
                console.log('Received message type:', msg.type);
                
                if (msg.type === "ping") {
                    ws.send(JSON.stringify({type: "pong"}));
                } else if (msg.type === "content") {
                    isReceiving = true;
                    
                    // Handle encrypted content
                    let content = msg.data;
                    if (msg.encrypted) {
                        try {
                            content = await decryptText(msg.data);
                        } catch (e) {
                            console.error("Failed to decrypt message");
                            content = "Error: Could not decrypt message";
                        }
                    }
                    
                    const currentValue = editor.value;
                    if (currentValue !== content) {
                        editor.value = content;
                    }
                    isReceiving = false;
                } else if (msg.type === "clients") {
                    document.title = `bluep (${msg.count})`;
                }
            };
    
            editor.oninput = async () => {
                if (!isReceiving && isConnected) {
                    const content = editor.value;
                    // Encrypt the content before sending
                    const encryptedData = await encryptText(content);
                    ws.send(JSON.stringify({
                        type: "content",
                        data: encryptedData,
                        encrypted: true,
                        keyId: "latest" // Use the latest key
                    }));
                }
            };
    
            // Activity monitoring
            let lastActivity = Date.now();
            const ACTIVITY_TIMEOUT = 30 * 60 * 1000; // milliseconds
    
            document.addEventListener('mousemove', () => lastActivity = Date.now());
            document.addEventListener('keypress', () => lastActivity = Date.now());
    
            function checkActivity() {
                if (Date.now() - lastActivity > ACTIVITY_TIMEOUT) {
                    window.location.reload(); // Refresh page if inactive
                }
            }
    
            function handleTOTPExpiry() {
                if (ws.readyState === WebSocket.CLOSED) {
                    window.location.href = '/login';
                }
            }
    
            function handleDisconnect() {
                if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    reconnectAttempts++;
                    setTimeout(() => {
                        if (ws.readyState === WebSocket.CLOSED) {
                            ws = new WebSocket(wsUrl);
                            initializeWebSocket(ws);
                        }
                    }, 1000 * reconnectAttempts);
                } else {
                    alert('Connection lost. Please refresh the page.');
                }
            }
    
            function initializeWebSocket(socket) {
                socket.onopen = async () => {
                    isConnected = true;
                    reconnectAttempts = 0;
                    console.log('Connected to server');
    
                    // Encrypt content before sending
                    const encryptedData = await encryptText(editor.value);
                    socket.send(JSON.stringify({
                        type: "content",
                        data: encryptedData,
                        encrypted: true,
                        keyId: "latest"
                    }));
                };
    
                socket.onclose = (event) => {
                    console.log('WebSocket closed:', event.code, event.reason);
                    isConnected = false;
                    handleDisconnect();
                };
    
                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
    
                socket.onmessage = async (event) => {
                    const msg = JSON.parse(event.data);
                    console.log('Received message type:', msg.type);
                    
                    if (msg.type === "ping") {
                        socket.send(JSON.stringify({type: "pong"}));
                    } else if (msg.type === "content") {
                        isReceiving = true;
                        
                        // Handle encrypted content
                        let content = msg.data;
                        if (msg.encrypted) {
                            try {
                                content = await decryptText(msg.data);
                            } catch (e) {
                                console.error("Failed to decrypt message");
                                content = "Error: Could not decrypt message";
                            }
                        }
                        
                        const currentValue = editor.value;
                        if (currentValue !== content) {
                            editor.value = content;
                        }
                        isReceiving = false;
                    } else if (msg.type === "clients") {
                        document.title = `bluep (${msg.count})`;
                    }
                };
            }
    
            // Regular checks
            setInterval(checkActivity, 60000); // Check activity every minute
        })();
    </script>
</body>
</html>
