<!DOCTYPE html>
<html>
<head>
    <title>bluep (0)</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    <!-- CSP is applied by middleware.py -->
    <style>
        body, html {
            margin: 0;
            padding: 8px;
            height: calc(100vh - 32px);
            width: calc(100vw - 32px);
            background: {{blue}};
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #editor {
            width: 100%;
            flex-grow: 1;
            margin: 0;
            padding: 16px;
            background-color: {{blue}};
            color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
            resize: none;
            box-sizing: border-box;
            position: relative;
        }
        #editor::before {
            content: "bluep";
            position: absolute;
            top: -0.5em;
            left: 3em;
            transform: translateX(-50%);
            background: {{blue}};
            padding: 0 10px;
            color: #fff;
        }
        #editor textarea {
            width: 100%;
            height: 100%;
            background-color: {{blue}};
            color: #fff;
            border: none;
            outline: none;
            resize: none;
            font-size: 16px;
            font-family: monospace;
            padding: 16px;
            box-sizing: border-box;
            overflow-wrap: anywhere;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.4;
        }
        #file-drop-area {
            height: 80px;
            width: 100%;
            margin-top: 16px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            transition: all 0.3s ease;
            position: relative;
        }
        #file-drop-area.drag-over {
            background-color: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }
        #file-list {
            width: 100%;
            padding: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .file-item {
            display: flex;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.1);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .file-item:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        .file-icon {
            margin-right: 8px;
            font-size: 18px;
        }
        #clear-files {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            border-radius: 4px;
            width: 30px;
            height: 30px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        #clear-files:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        
        /* Navigation bar */
        .nav-bar {
            background: #0a0a1a;
            padding: 10px 20px;
            margin: -8px -8px 8px -8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #2a2a4e;
        }
        
        .nav-links {
            display: flex;
            gap: 20px;
        }
        
        .nav-link {
            color: #aaa;
            text-decoration: none;
            font-size: 14px;
            transition: color 0.2s;
        }
        
        .nav-link:hover {
            color: #3498db;
        }
        
        .nav-link.active {
            color: #3498db;
            font-weight: bold;
        }
    </style>
    <script src="/static/js/crypto-utils.js"></script>
</head>
<body>
    <div class="nav-bar">
        <div class="nav-links">
            <a href="/" class="nav-link active">Editor</a>
            <a href="/terminal" class="nav-link">Terminal</a>
            <a href="/mcp" class="nav-link">MCP Services</a>
        </div>
        <div style="color: #666; font-size: 12px;">bluep</div>
    </div>
    <div id="editor">
        <textarea autofocus></textarea>
    </div>
    <div id="file-drop-area">
        <div id="file-list"></div>
        <button id="clear-files" title="Clear all file listings">üóëÔ∏è</button>
    </div>
    <script>
        // Security: Verify the connection and check for tampering
        document.addEventListener('DOMContentLoaded', function() {
            // Verify certificate and detect tampering
            verifyConnection("{{cert_fingerprint}}");
            detectExtensionTampering({{script_length}});
            
            // Check security verification every minute
            setInterval(() => verifyConnection("{{cert_fingerprint}}"), 60000);
        });
        
        // Initialize main application after security checks
        (async function() {
            // Use a shared key for all clients to ensure seamless communication
            const token = "{{token}}";
            const sharedKeyStr = "{{shared_key}}";
            let encryptionKey = null;
            
            try {
                // Instead of generating a key from the individual token,
                // we'll use the shared key that the server provides to all clients
                console.log("Using server-provided shared encryption key");
                
                // Convert the shared key to a cryptographic key
                sharedSecret = await createKeyFromSharedString(sharedKeyStr);
                
                console.log("Shared encryption key setup completed");
            } catch (e) {
                console.warn("Error with shared key, falling back to token-based method:", e);
                try {
                    // Fall back to token-based encryption if shared key fails
                    sharedSecret = await fallbackToTokenBasedKey(token);
                    if (sharedSecret) {
                        console.log("Created fallback encryption key");
                    } else {
                        console.error("Failed to create any encryption key");
                    }
                } catch (keyError) {
                    console.error("Failed to create fallback key:", keyError);
                }
            }
            
            // Create WebSocket using token from secure cookie
            // We still need the token for encryption/decryption in the browser
            const wsUrl = `wss://${window.location.host}/ws`;
            let ws = new WebSocket(wsUrl);
            
            // Track connection state
            let isConnected = false;
            let reconnectAttempts = 0;
            const MAX_RECONNECT_ATTEMPTS = 5;
            const editor = document.querySelector('#editor textarea');
            let isReceiving = false;
            
            ws.onopen = async () => {
                isConnected = true;
                reconnectAttempts = 0;
                console.log('Connected to server');
    
                // Send initial message with encryption
                const encryptedData = await encryptText("bluep");
                ws.send(JSON.stringify({
                    type: "content",
                    data: encryptedData,
                    encrypted: true
                }));
            };
    
            ws.onclose = (event) => {
                console.log('WebSocket closed:', event.code, event.reason);
                isConnected = false;
                if (event.code === 403) {
                    handleTOTPExpiry();
                } else {
                    handleDisconnect();
                }
            };
    
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
    
            // Add message handler
            ws.onmessage = async (event) => {
                // Don't log sensitive data
                const msg = JSON.parse(event.data);
                console.log('Received message type:', msg.type);
                
                if (msg.type === "ping") {
                    ws.send(JSON.stringify({type: "pong"}));
                } else if (msg.type === "content") {
                    isReceiving = true;
                    
                    // All content must be encrypted
                    let content = msg.data;
                    
                    // First validate that we have actual data to decrypt
                    if (!content) {
                        console.error("Received empty content data");
                        isReceiving = false;
                        return;
                    }
                    
                    if (msg.encrypted) {
                        try {
                            // Add validation before decryption attempt
                            if (typeof content !== 'string') {
                                throw new Error("Content must be a string for decryption");
                            }
                            
                            content = await decryptText(content);
                        } catch (e) {
                            console.error("Decryption error:", e);
                            // Reject content that can't be decrypted
                            isReceiving = false;
                            return;
                        }
                    } else {
                        // Reject unencrypted content for security
                        console.error("Rejected unencrypted content for security");
                        isReceiving = false;
                        return;
                    }
                    
                    const currentValue = editor.value;
                    if (currentValue !== content) {
                        editor.value = content;
                    }
                    isReceiving = false;
                } else if (msg.type === "clients") {
                    // Title updates now handled with an Object.defineProperty wrapper
                    document.title = `bluep (${msg.count})`;
                } else if (msg.type === "file-announce") {
                    handleFileAnnouncement(msg);
                } else if (msg.type === "file-request" && msg.fileId) {
                    // Someone requested a file we have
                    const fileId = msg.fileId;
                    if (availableFiles[fileId] && availableFiles[fileId].isLocal) {
                        sendFile(fileId);
                    }
                } else if (msg.type === "file-transfer-start") {
                    // Show transfer starting notification
                    const fileId = msg.fileId;
                    const fileName = msg.fileName;
                    const fileSize = msg.fileSize || 0;
                    
                    // Format file size for display
                    let fileSizeText = "Unknown size";
                    if (fileSize > 0) {
                        if (fileSize < 1024 * 1024) {
                            fileSizeText = `${(fileSize / 1024).toFixed(1)} KB`;
                        } else {
                            fileSizeText = `${(fileSize / (1024 * 1024)).toFixed(1)} MB`;
                        }
                    }
                    
                    // Show toast notification
                    const notification = document.createElement('div');
                    notification.textContent = `File transfer starting: ${fileName} (${fileSizeText})`;
                    notification.style.position = 'fixed';
                    notification.style.bottom = '20px';
                    notification.style.right = '20px';
                    notification.style.padding = '10px 20px';
                    notification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                    notification.style.color = 'white';
                    notification.style.borderRadius = '4px';
                    notification.style.zIndex = '1000';
                    document.body.appendChild(notification);
                    
                    // Remove after a few seconds
                    setTimeout(() => {
                        document.body.removeChild(notification);
                    }, 3000);
                } else if (msg.type === "file-data") {
                    handleFileData(msg);
                } else if (msg.type === "clear-files") {
                    // Clear file listings
                    fileList.innerHTML = '';
                    availableFiles = {};
                }
            };
    
            // Debounce mechanism for large paste operations
            let updateTimeout = null;
            const DEBOUNCE_TIME = 300; // ms
            
            // Handle large text updates more efficiently with debouncing
            editor.oninput = async () => {
                if (!isReceiving && isConnected) {
                    // Clear any pending update
                    if (updateTimeout) {
                        clearTimeout(updateTimeout);
                    }
                    
                    // Set a new timeout for update
                    updateTimeout = setTimeout(async () => {
                        const content = editor.value;
                        // Always use encryption - no fallback to plaintext
                        try {
                            const encryptedData = await encryptText(content);
                            ws.send(JSON.stringify({
                                type: "content",
                                data: encryptedData,
                                encrypted: true
                            }));
                        } catch (e) {
                            console.error("Encryption error:", e);
                            // Don't send unencrypted data
                            console.error("Message not sent due to encryption failure");
                        }
                    }, DEBOUNCE_TIME);
                }
            };
    
            // Activity monitoring
            let lastActivity = Date.now();
            const ACTIVITY_TIMEOUT = 30 * 60 * 1000; // milliseconds
    
            document.addEventListener('mousemove', () => lastActivity = Date.now());
            document.addEventListener('keypress', () => lastActivity = Date.now());
            
            // Set up clear files button
            document.getElementById('clear-files').addEventListener('click', () => {
                // Clear local UI
                fileList.innerHTML = '';
                
                // Clear local storage
                availableFiles = {};
                
                // Send clear message to all clients
                if (isConnected) {
                    ws.send(JSON.stringify({
                        type: "clear-files"
                    }));
                }
            });
            
            // File drag and drop implementation
            const fileDropArea = document.getElementById('file-drop-area');
            const fileList = document.getElementById('file-list');
            const MAX_FILE_SIZE = 200 * 1024 * 1024; // 200MB limit
            const CHUNK_SIZE = 256 * 1024; // 256KB chunks for file transfer for better performance
            let availableFiles = {}; // Store file metadata from other clients
            
            // Set up drag and drop event handlers
            fileDropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                fileDropArea.classList.add('drag-over');
            });
            
            fileDropArea.addEventListener('dragleave', () => {
                fileDropArea.classList.remove('drag-over');
            });
            
            fileDropArea.addEventListener('drop', async (e) => {
                e.preventDefault();
                fileDropArea.classList.remove('drag-over');
                
                if (!e.dataTransfer.files.length) return;
                
                const file = e.dataTransfer.files[0]; // Just handle the first file for now
                
                if (file.size > MAX_FILE_SIZE) {
                    alert(`File too large. Maximum size is ${MAX_FILE_SIZE / (1024 * 1024)}MB`);
                    return;
                }
                
                // Show user the file is being processed
                const processingIndicator = document.createElement('div');
                processingIndicator.textContent = `Processing ${file.name}...`;
                processingIndicator.style.color = '#fff';
                processingIndicator.style.padding = '8px';
                processingIndicator.style.marginTop = '4px';
                fileDropArea.appendChild(processingIndicator);
                
                // Generate a unique file ID
                const fileId = Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
                
                // Announce the file to other clients
                if (isConnected) {
                    ws.send(JSON.stringify({
                        type: "file-announce",
                        fileId: fileId,
                        fileName: file.name,
                        fileSize: file.size,
                        fileType: file.type || "application/octet-stream"
                    }));
                    
                    // Store the file locally
                    availableFiles[fileId] = {
                        file: file,
                        id: fileId,
                        size: file.size,
                        isLocal: true
                    };
                    
                    // Add to the UI
                    displayFile(fileId, file.name, true);
                    
                    // Remove the processing indicator
                    fileDropArea.removeChild(processingIndicator);
                }
            });
            
            // Function to display a file in the UI with size information
            function displayFile(fileId, fileName, isLocal) {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.dataset.fileId = fileId;
                fileItem.id = `file-item-${fileId}`;
                
                const icon = document.createElement('span');
                icon.className = 'file-icon';
                icon.innerHTML = 'üìÑ';
                icon.id = `file-icon-${fileId}`;
                
                // Add progress bar container
                const progressContainer = document.createElement('div');
                progressContainer.className = 'progress-container';
                progressContainer.style.display = 'none';
                progressContainer.style.width = '100%';
                progressContainer.style.height = '4px';
                progressContainer.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                progressContainer.style.borderRadius = '2px';
                progressContainer.style.marginTop = '4px';
                
                const progressBar = document.createElement('div');
                progressBar.className = 'progress-bar';
                progressBar.id = `progress-${fileId}`;
                progressBar.style.width = '0%';
                progressBar.style.height = '100%';
                progressBar.style.backgroundColor = 'rgba(0, 255, 100, 0.6)';
                progressBar.style.borderRadius = '2px';
                progressBar.style.transition = 'width 0.2s ease';
                
                progressContainer.appendChild(progressBar);
                
                const nameContainer = document.createElement('div');
                nameContainer.style.display = 'flex';
                nameContainer.style.flexDirection = 'column';
                
                const name = document.createElement('span');
                name.textContent = fileName;
                
                const sizeInfo = document.createElement('span');
                sizeInfo.style.fontSize = '0.8em';
                sizeInfo.style.color = 'rgba(255, 255, 255, 0.7)';
                
                // Format the file size
                if (availableFiles[fileId] && availableFiles[fileId].size) {
                    const size = availableFiles[fileId].size;
                    let sizeText;
                    if (size < 1024) {
                        sizeText = `${size} B`;
                    } else if (size < 1024 * 1024) {
                        sizeText = `${(size / 1024).toFixed(1)} KB`;
                    } else {
                        sizeText = `${(size / (1024 * 1024)).toFixed(1)} MB`;
                    }
                    sizeInfo.textContent = sizeText;
                }
                
                nameContainer.appendChild(name);
                nameContainer.appendChild(sizeInfo);
                
                fileItem.appendChild(icon);
                fileItem.appendChild(nameContainer);
                fileItem.appendChild(progressContainer);
                
                if (!isLocal) {
                    fileItem.addEventListener('click', () => {
                        requestFile(fileId);
                    });
                    fileItem.title = "Click to download";
                    fileItem.style.cursor = "pointer";
                }
                
                fileList.appendChild(fileItem);
            }
            
            // Request a file from another client
            function requestFile(fileId) {
                if (!availableFiles[fileId] || availableFiles[fileId].isLocal) return;
                
                console.log(`Requesting file: ${fileId} (${availableFiles[fileId].name})`);
                
                // Show progress bar for the file before transfer starts
                const progressContainer = document.querySelector(`#file-item-${fileId} .progress-container`);
                if (progressContainer) {
                    progressContainer.style.display = 'block';
                }
                
                // Update the icon to indicate download is starting
                const iconElement = document.getElementById(`file-icon-${fileId}`);
                if (iconElement) {
                    iconElement.innerHTML = '‚†Ç'; // Start with the least filled icon
                }
                
                // Reset any existing data for this file
                availableFiles[fileId] = {
                    id: fileId,
                    name: availableFiles[fileId].name,
                    size: availableFiles[fileId].size,
                    type: availableFiles[fileId].type,
                    chunks: {},
                    receivedChunks: 0,
                    totalChunks: 0,
                    isLocal: false
                };
                
                ws.send(JSON.stringify({
                    type: "file-request",
                    fileId: fileId
                }));
            }
            
            // Handle file announcement from another client
            function handleFileAnnouncement(msg) {
                if (!msg.fileId || !msg.fileName) return;
                
                // Store file metadata
                availableFiles[msg.fileId] = {
                    id: msg.fileId,
                    name: msg.fileName,
                    size: msg.fileSize,
                    type: msg.fileType,
                    isLocal: false
                };
                
                // Add to UI
                displayFile(msg.fileId, msg.fileName, false);
            }
            
            // Function to update file transfer progress in the UI
            function updateFileProgress(fileId, current, total) {
                if (!fileId || !total) return;
                
                const progressBar = document.getElementById(`progress-${fileId}`);
                const progressContainer = document.querySelector(`#file-item-${fileId} .progress-container`);
                const iconElement = document.getElementById(`file-icon-${fileId}`);
                
                if (!progressBar || !progressContainer) return;
                
                // Show progress container if not already visible
                progressContainer.style.display = 'block';
                
                // Calculate percentage
                const percent = Math.min(Math.round((current / total) * 100), 100);
                progressBar.style.width = `${percent}%`;
                
                // Change color based on progress
                if (percent < 30) {
                    progressBar.style.backgroundColor = 'rgba(255, 165, 0, 0.7)'; // Orange
                } else if (percent < 70) {
                    progressBar.style.backgroundColor = 'rgba(255, 255, 0, 0.7)'; // Yellow
                } else {
                    progressBar.style.backgroundColor = 'rgba(0, 255, 100, 0.7)'; // Green
                }
                
                // Update the icon based on progress with filling indicators and flickering
                if (iconElement) {
                    if (percent === 100) {
                        iconElement.innerHTML = '‚úÖ';
                    } else if (percent > 0) {
                        // Define our icons from least to most filled
                        const icons = ['‚†Ç', '‚†Ñ', '‚°†', '‚£Ä', '‚£§', '‚£∂', '‚£ø'];
                        
                        // Calculate which threshold range we're in (0-6)
                        const thresholdSize = 15;
                        const baseIndex = Math.floor(percent / thresholdSize);
                        
                        // Calculate how far we are into the current threshold (0-1)
                        const withinThreshold = (percent % thresholdSize) / thresholdSize;
                        
                        // Use the linear interpolation to decide whether to show current or next icon
                        const shouldShowNextIcon = Math.random() < withinThreshold;
                        
                        // Choose current or next icon based on interpolation
                        const iconIndex = Math.min(baseIndex + (shouldShowNextIcon ? 1 : 0), icons.length - 1);
                        
                        // Set the icon
                        iconElement.innerHTML = icons[iconIndex];
                    } else {
                        iconElement.innerHTML = 'üì•';
                    }
                }
            }
            
            // Handle file data from another client
            async function handleFileData(msg) {
                if (!msg.fileId) return;
                
                // Validate data format - skip invalid chunks
                if (!msg.data || typeof msg.data !== 'string' || msg.data.length < 16) {
                    console.warn(`Received invalid chunk format for file ${msg.fileId}, chunk ${msg.fileChunk}`);
                    return;
                }
                
                // We're receiving a file - collect chunks
                if (!availableFiles[msg.fileId]) {
                    availableFiles[msg.fileId] = {
                        id: msg.fileId,
                        name: msg.fileName || 'downloaded_file',
                        chunks: {},  // Change to object instead of array
                        receivedChunks: 0,
                        totalChunks: msg.totalChunks || 0,
                        isLocal: false,
                        retryCount: 0, // Track retries for problematic chunks
                        failedChunks: {} // Track which chunks failed
                    };
                }
                
                const fileInfo = availableFiles[msg.fileId];
                const chunkIndex = parseInt(msg.fileChunk, 10);
                
                // Make sure chunk index is valid
                if (isNaN(chunkIndex) || chunkIndex < 0) {
                    console.warn(`Invalid chunk index ${msg.fileChunk} for file ${fileInfo.name}`);
                    return;
                }
                
                // Update the progress in the UI - don't update with just the chunk index,
                // since chunks might arrive out of order. Instead, use current received count
                // or 1 for the first chunk to ensure the icon changes immediately
                if (fileInfo && fileInfo.receivedChunks) {
                    updateFileProgress(msg.fileId, fileInfo.receivedChunks, fileInfo.totalChunks);
                } else {
                    // Force at least 1% progress to update the icon
                    updateFileProgress(msg.fileId, 1, 100);
                }
                
                // Check if we already have this chunk
                if (fileInfo.chunks && fileInfo.chunks[chunkIndex] !== undefined) {
                    console.log(`Already received chunk ${chunkIndex} for file ${fileInfo.name}, skipping`);
                    return;
                }
                
                // Check if we've had too many failures with this chunk
                if (fileInfo.failedChunks && fileInfo.failedChunks[chunkIndex] && fileInfo.failedChunks[chunkIndex] > 3) {
                    console.warn(`Skipping problematic chunk ${chunkIndex} that failed multiple decryption attempts`);
                    return;
                }
                
                // Initialize chunks and failedChunks if not already done
                if (!fileInfo.chunks) fileInfo.chunks = {};
                if (!fileInfo.failedChunks) fileInfo.failedChunks = {};
                
                // Add this chunk
                let chunkData = msg.data;
                
                // Decrypt the chunk - all data must be encrypted
                if (msg.encrypted) {
                    try {
                        chunkData = await decryptText(chunkData);
                        
                        // Reset retry count for this chunk on success
                        if (fileInfo.failedChunks && fileInfo.failedChunks[chunkIndex]) {
                            delete fileInfo.failedChunks[chunkIndex];
                        }
                        
                        // Only log for first chunk or every 10th chunk to reduce console spam
                        if (chunkIndex === 0 || chunkIndex % 10 === 0) {
                            console.log(`Successfully decrypted chunk ${chunkIndex} of size ${chunkData.length}`);
                        }
                    } catch (e) {
                        console.error(`Failed to decrypt file chunk ${chunkIndex}:`, e);
                        
                        // Track failed decryption attempts for this chunk
                        if (!fileInfo.failedChunks) fileInfo.failedChunks = {};
                        fileInfo.failedChunks[chunkIndex] = (fileInfo.failedChunks[chunkIndex] || 0) + 1;
                        if (typeof fileInfo.retryCount !== 'number') fileInfo.retryCount = 0;
                        fileInfo.retryCount++;
                        
                        // If too many overall failures, show error to user
                        if (fileInfo.retryCount > 10) {
                            console.error(`Too many decryption failures for file ${fileInfo.name}, transfer may be corrupted`);
                            
                            // Show error notification
                            const errorNotification = document.createElement('div');
                            errorNotification.textContent = `Error downloading ${fileInfo.name}: Too many decryption failures`;
                            errorNotification.style.position = 'fixed';
                            errorNotification.style.bottom = '20px';
                            errorNotification.style.right = '20px';
                            errorNotification.style.padding = '10px 20px';
                            errorNotification.style.backgroundColor = 'rgba(200, 0, 0, 0.8)';
                            errorNotification.style.color = 'white';
                            errorNotification.style.borderRadius = '4px';
                            errorNotification.style.zIndex = '1000';
                            document.body.appendChild(errorNotification);
                            
                            setTimeout(() => {
                                document.body.removeChild(errorNotification);
                            }, 5000);
                        }
                        
                        // Reject chunks that can't be decrypted
                        return;
                    }
                } else {
                    // Reject unencrypted chunks for security
                    console.error("Rejected unencrypted file chunk for security");
                    return;
                }
                
                // Make sure we have totalChunks info
                if (msg.totalChunks) {
                    fileInfo.totalChunks = parseInt(msg.totalChunks, 10);
                    console.log(`File has ${fileInfo.totalChunks} total chunks`);
                }
                
                // This is now handled earlier
                
                // We already parsed chunk index above (no need to redefine)
                
                // Store the chunk
                fileInfo.chunks[chunkIndex] = chunkData;
                fileInfo.receivedChunks = Object.keys(fileInfo.chunks).length;
                
                // Update the progress bar
                updateFileProgress(msg.fileId, fileInfo.receivedChunks, fileInfo.totalChunks);
                
                // Only log occasionally to reduce console spam
                if (chunkIndex === 0 || chunkIndex % 10 === 0 || chunkIndex === fileInfo.totalChunks - 1) {
                    console.log(`Received chunk ${chunkIndex + 1}/${fileInfo.totalChunks} for ${fileInfo.name} (total received: ${fileInfo.receivedChunks})`);
                }
                
                // If we have all chunks, assemble and download the file
                if (fileInfo.receivedChunks >= fileInfo.totalChunks) {
                    console.log(`Received all ${fileInfo.totalChunks} chunks for file ${fileInfo.name}`);
                    
                    // Show assembly progress for large files
                    let assemblyNotification;
                    if (fileInfo.totalChunks > 20) { // Only show for larger files
                        assemblyNotification = document.createElement('div');
                        assemblyNotification.textContent = `Assembling ${fileInfo.name}...`;
                        assemblyNotification.style.position = 'fixed';
                        assemblyNotification.style.bottom = '20px';
                        assemblyNotification.style.right = '20px';
                        assemblyNotification.style.padding = '10px 20px';
                        assemblyNotification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                        assemblyNotification.style.color = 'white';
                        assemblyNotification.style.borderRadius = '4px';
                        document.body.appendChild(assemblyNotification);
                    }
                    
                    try {
                        // Use setTimeout to allow UI to update before CPU-intensive operations
                        setTimeout(async () => {
                            try {
                                const fileBlob = assembleFile(fileInfo.chunks, fileInfo.type || 'application/octet-stream');
                                downloadFile(fileBlob, fileInfo.name);
                                
                                // Update icon to show completed
                                const iconElement = document.getElementById(`file-icon-${msg.fileId}`);
                                if (iconElement) {
                                    iconElement.innerHTML = '‚úÖ';
                                }
                                
                                // Clean up chunks to free memory
                                delete fileInfo.chunks;
                                
                                // Remove notification if it exists
                                if (assemblyNotification) {
                                    document.body.removeChild(assemblyNotification);
                                }
                            } catch (error) {
                                console.error("Error assembling or downloading file:", error);
                                if (assemblyNotification) {
                                    assemblyNotification.textContent = `Error assembling ${fileInfo.name}`;
                                    setTimeout(() => {
                                        document.body.removeChild(assemblyNotification);
                                    }, 3000);
                                }
                            }
                        }, 50);
                    } catch (error) {
                        console.error("Error scheduling file assembly:", error);
                        if (assemblyNotification) {
                            document.body.removeChild(assemblyNotification);
                        }
                    }
                }
            }
            
            // Send file data to a client that requested it
            async function sendFile(fileId) {
                const fileInfo = availableFiles[fileId];
                if (!fileInfo || !fileInfo.isLocal || !fileInfo.file) {
                    console.error(`Cannot send file ${fileId}: file not found or not local`);
                    return;
                }
                
                const file = fileInfo.file;
                const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
                console.log(`Sending file ${file.name} (${file.size} bytes) in ${totalChunks} chunks`);
                
                // Show progress UI element before transfer starts
                const progressContainer = document.querySelector(`#file-item-${fileId} .progress-container`);
                const progressBar = document.getElementById(`progress-${fileId}`);
                const iconElement = document.getElementById(`file-icon-${fileId}`);
                
                if (progressContainer) {
                    progressContainer.style.display = 'block';
                }
                
                if (iconElement) {
                    iconElement.innerHTML = '‚†Ç'; // Start with the least filled icon
                }
                
                // Send file in chunks
                for (let i = 0; i < totalChunks; i++) {
                    const start = i * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE, file.size);
                    const chunk = file.slice(start, end);
                    
                    // Update progress bar
                    if (progressBar) {
                        const percent = Math.min(Math.round((i / totalChunks) * 100), 100);
                        progressBar.style.width = `${percent}%`;
                        
                        // Change color based on progress
                        if (percent < 30) {
                            progressBar.style.backgroundColor = 'rgba(255, 165, 0, 0.7)'; // Orange
                        } else if (percent < 70) {
                            progressBar.style.backgroundColor = 'rgba(255, 255, 0, 0.7)'; // Yellow
                        } else {
                            progressBar.style.backgroundColor = 'rgba(0, 255, 100, 0.7)'; // Green
                        }
                        
                        // Update the upload icon based on progress with filling indicators and flickering
                        if (iconElement) {
                            if (percent === 100) {
                                iconElement.innerHTML = '‚úÖ';
                            } else if (percent > 0) {
                                // Define our icons from least to most filled
                                const icons = ['‚†Ç', '‚†Ñ', '‚°†', '‚£Ä', '‚£§', '‚£∂', '‚£ø'];
                                
                                // Calculate which threshold range we're in (0-6)
                                const thresholdSize = 15;
                                const baseIndex = Math.floor(percent / thresholdSize);
                                
                                // Calculate how far we are into the current threshold (0-1)
                                const withinThreshold = (percent % thresholdSize) / thresholdSize;
                                
                                // Use the linear interpolation to decide whether to show current or next icon
                                const shouldShowNextIcon = Math.random() < withinThreshold;
                                
                                // Choose current or next icon based on interpolation
                                const iconIndex = Math.min(baseIndex + (shouldShowNextIcon ? 1 : 0), icons.length - 1);
                                
                                // Set the icon
                                iconElement.innerHTML = icons[iconIndex];
                            }
                        }
                    }
                    
                    console.log(`Preparing chunk ${i+1}/${totalChunks}, size: ${chunk.size} bytes`);
                    
                    // For large chunks, process more efficiently
                    if (chunk.size > 1024 * 1024) { // For chunks > 1MB
                        console.log(`Processing large chunk ${i+1}/${totalChunks} (${chunk.size} bytes) with optimized method`);
                    }
                    
                    // Convert chunk to base64
                    const fileReader = new FileReader();
                    await new Promise((resolve) => {
                        fileReader.onloadend = resolve;
                        fileReader.readAsDataURL(chunk);
                    });
                    
                    // Extract the base64 data without the prefix
                    let base64Data = fileReader.result.split(',')[1];
                    
                    // Only log for smaller chunks or first/last chunk
                    if (chunk.size < 1024 * 1024 || i === 0 || i === totalChunks - 1) {
                        console.log(`Chunk ${i+1}/${totalChunks} converted to base64, length: ${base64Data.length}`);
                    }
                    
                    try {
                        // Display progress indicator for large files
                        if (totalChunks > 50 && i % Math.ceil(totalChunks/10) === 0) {
                            const progress = Math.floor((i / totalChunks) * 100);
                            console.log(`File transfer progress: ${progress}%`);
                            
                            // Show progress notification
                            const progressNotification = document.createElement('div');
                            progressNotification.textContent = `Sending ${file.name}: ${progress}% complete`;
                            progressNotification.style.position = 'fixed';
                            progressNotification.style.bottom = '20px';
                            progressNotification.style.right = '20px';
                            progressNotification.style.padding = '10px 20px';
                            progressNotification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                            progressNotification.style.color = 'white';
                            progressNotification.style.borderRadius = '4px';
                            progressNotification.style.zIndex = '1000';
                            progressNotification.id = 'progress-notification';
                            
                            // Remove any existing notification
                            const existingNotification = document.getElementById('progress-notification');
                            if (existingNotification) {
                                document.body.removeChild(existingNotification);
                            }
                            
                            document.body.appendChild(progressNotification);
                            
                            // Remove after 2 seconds
                            setTimeout(() => {
                                if (document.getElementById('progress-notification')) {
                                    document.body.removeChild(progressNotification);
                                }
                            }, 2000);
                        }
                    
                        // Encrypt the chunk
                        const encryptedData = await encryptText(base64Data);
                        
                        // Send the chunk
                        ws.send(JSON.stringify({
                            type: "file-data",
                            fileId: fileId,
                            fileName: file.name,
                            fileType: file.type || "application/octet-stream",
                            fileChunk: i.toString(),  // Ensure it's a string
                            totalChunks: totalChunks.toString(),  // Ensure it's a string
                            data: encryptedData,
                            encrypted: true
                        }));
                        
                        // Only log occasionally to reduce console spam
                        if (i === 0 || i === totalChunks - 1 || i % 50 === 0) {
                            console.log(`Sent chunk ${i+1}/${totalChunks} of file ${file.name}`);
                        }
                    } catch (e) {
                        console.error(`Error sending chunk ${i}:`, e);
                        // Don't send unencrypted data - abort the file transfer
                        console.error("File chunk sending aborted due to encryption failure");
                        
                        // Show error notification
                        const errorNotification = document.createElement('div');
                        errorNotification.textContent = `Error sending ${file.name}: ${e.message}`;
                        errorNotification.style.position = 'fixed';
                        errorNotification.style.bottom = '20px';
                        errorNotification.style.right = '20px';
                        errorNotification.style.padding = '10px 20px';
                        errorNotification.style.backgroundColor = 'rgba(200, 0, 0, 0.8)';
                        errorNotification.style.color = 'white';
                        errorNotification.style.borderRadius = '4px';
                        errorNotification.style.zIndex = '1000';
                        document.body.appendChild(errorNotification);
                        
                        setTimeout(() => {
                            document.body.removeChild(errorNotification);
                        }, 5000);
                        
                        return; // Stop the file sending process
                    }
                    
                    // Adaptive delay based on chunk size to prevent overwhelming the connection
                    // Larger chunks need more time to process
                    const chunkDelay = Math.min(50 + (chunk.size / 1024), 200); // 50-200ms delay
                    await new Promise(resolve => setTimeout(resolve, chunkDelay));
                }
                
                console.log(`Completed sending file ${file.name}`);
                
                // Mark as completed after sending
                if (iconElement) {
                    iconElement.innerHTML = '‚úÖ';
                }
                
                if (progressBar) {
                    progressBar.style.width = '100%';
                    progressBar.style.backgroundColor = 'rgba(0, 255, 100, 0.7)';
                }
            }
            
            // Assemble file chunks into a blob
            function assembleFile(chunks, mimeType) {
                // Get all chunks in order
                const orderedChunks = [];
                const chunkIndices = Object.keys(chunks).map(Number).sort((a, b) => a - b);
                const totalChunks = chunkIndices.length;
                
                console.log(`Assembling file from ${totalChunks} chunks with indices: ${chunkIndices.join(', ')}`);
                
                // Validate that we have all the chunks we need
                let missingChunks = false;
                for (let i = 0; i < totalChunks; i++) {
                    if (!chunkIndices.includes(i)) {
                        console.error(`Missing chunk at index ${i}`);
                        missingChunks = true;
                    }
                }
                
                if (missingChunks) {
                    console.warn("Some chunks are missing, but attempting to assemble anyway");
                }
                
                // Convert chunks object to ordered array using the sorted indices
                for (let i = 0; i < chunkIndices.length; i++) {
                    const chunkIndex = chunkIndices[i];
                    if (chunks[chunkIndex] === undefined) {
                        console.error(`Missing chunk ${chunkIndex}`);
                        continue;
                    }
                    
                    const chunk = chunks[chunkIndex];
                    console.log(`Adding chunk ${chunkIndex} to ordered array, data length: ${chunk.length || 0}`);
                    orderedChunks.push(chunk);
                }
                
                // Convert base64 chunks to binary
                const binaryChunks = orderedChunks.map((chunk, index) => {
                    try {
                        console.log(`Converting chunk ${index} to binary, base64 length: ${chunk.length}`);
                        const binary = atob(chunk);
                        console.log(`Decoded chunk ${index}, binary length: ${binary.length}`);
                        return binary;
                    } catch (e) {
                        console.error(`Failed to decode base64 chunk ${index}:`, e);
                        console.log(`Problematic base64 chunk sample: ${chunk.substring(0, 30)}...`);
                        return '';
                    }
                });
                
                // Convert to Uint8Array
                const uint8Chunks = binaryChunks.map(binary => {
                    const bytes = new Uint8Array(binary.length);
                    for (let i = 0; i < binary.length; i++) {
                        bytes[i] = binary.charCodeAt(i);
                    }
                    return bytes;
                });
                
                // Assemble the file
                const fileBlob = new Blob(uint8Chunks, { type: mimeType });
                return fileBlob;
            }
            
            // Download the assembled file
            function downloadFile(blob, fileName) {
                try {
                    console.log(`Downloading file: ${fileName}, size: ${blob.size} bytes`);
                    const url = URL.createObjectURL(blob);
                    
                    // Create a download link that's less likely to trigger tampering alerts
                    const downloadContainer = document.createElement('div');
                    downloadContainer.setAttribute('id', 'download-container');
                    downloadContainer.style.position = 'absolute';
                    downloadContainer.style.top = '-1000px';
                    downloadContainer.style.left = '-1000px';
                    
                    const a = document.createElement('a');
                    a.setAttribute('id', 'download-link');
                    a.href = url;
                    a.download = fileName;
                    a.textContent = 'Download';
                    
                    // Add to DOM and trigger download
                    downloadContainer.appendChild(a);
                    document.body.appendChild(downloadContainer);
                    console.log("Triggering download...");
                    
                    // Use a short delay to ensure DOM is updated before clicking
                    setTimeout(() => {
                        a.click();
                        
                        // Clean up
                        setTimeout(() => {
                            try {
                                document.body.removeChild(downloadContainer);
                                URL.revokeObjectURL(url);
                                console.log("Download link cleaned up");
                            } catch (e) {
                                console.warn("Error during cleanup:", e);
                            }
                        }, 1000);
                    }, 50);
                    
                } catch (error) {
                    console.error("Error downloading file:", error);
                }
            }
    
            function checkActivity() {
                if (Date.now() - lastActivity > ACTIVITY_TIMEOUT) {
                    window.location.reload(); // Refresh page if inactive
                }
            }
    
            function handleTOTPExpiry() {
                if (ws.readyState === WebSocket.CLOSED) {
                    window.location.href = '/login';
                }
            }
    
            function handleDisconnect() {
                if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    reconnectAttempts++;
                    setTimeout(() => {
                        if (ws.readyState === WebSocket.CLOSED) {
                            ws = new WebSocket(wsUrl);
                            initializeWebSocket(ws);
                        }
                    }, 1000 * reconnectAttempts);
                } else {
                    alert('Connection lost. Please refresh the page.');
                }
            }
    
            function initializeWebSocket(socket) {
                socket.onopen = async () => {
                    isConnected = true;
                    reconnectAttempts = 0;
                    console.log('Connected to server');
    
                    // Always use encryption - no fallback to plaintext
                    try {
                        const encryptedData = await encryptText(editor.value);
                        socket.send(JSON.stringify({
                            type: "content",
                            data: encryptedData,
                            encrypted: true
                        }));
                    } catch (e) {
                        console.error("Encryption error:", e);
                        // Don't send unencrypted data
                        console.error("Message not sent due to encryption failure");
                    }
                };
    
                socket.onclose = (event) => {
                    console.log('WebSocket closed:', event.code, event.reason);
                    isConnected = false;
                    handleDisconnect();
                };
    
                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
    
                socket.onmessage = async (event) => {
                    const msg = JSON.parse(event.data);
                    console.log('Received message type:', msg.type);
                    
                    if (msg.type === "ping") {
                        socket.send(JSON.stringify({type: "pong"}));
                    } else if (msg.type === "content") {
                        // All content must be encrypted
                        let content = msg.data;
                        if (msg.encrypted) {
                            try {
                                content = await decryptText(content);
                            } catch (e) {
                                console.error("Decryption error:", e);
                                // Reject content that can't be decrypted
                                return;
                            }
                        } else {
                            // Reject unencrypted content for security
                            console.error("Rejected unencrypted content for security");
                            return;
                        }
                        isReceiving = true;
                        
                        const currentValue = editor.value;
                        if (currentValue !== content) {
                            editor.value = content;
                        }
                        isReceiving = false;
                    } else if (msg.type === "clients") {
                        document.title = `bluep (${msg.count})`;
                    }
                };
            }
    
            // Regular checks
            setInterval(checkActivity, 60000); // Check activity every minute
        })();
    </script>
</body>
</html>
