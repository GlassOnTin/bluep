<!DOCTYPE html>
<html>
<head>
    <title>bluep (0)</title>
    <link rel="icon" type="image/png" href="/favicon.png?key={{key}}">
    <!-- CSP is applied by middleware.py -->
    <style>
        body, html {
            margin: 0;
            padding: 8px;
            height: calc(100vh - 32px);
            width: calc(100vw - 32px);
            background: {{blue}};
            overflow: hidden;
        }
        #editor {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 16px;
            background-color: {{blue}};
            color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
            resize: none;
            box-sizing: border-box;
            position: relative;
        }
        #editor::before {
            content: "bluep";
            position: absolute;
            top: -0.5em;
            left: 3em;
            transform: translateX(-50%);
            background: {{blue}};
            padding: 0 10px;
            color: #fff;
        }
        #editor textarea {
            width: 100%;
            height: 100%;
            background-color: {{blue}};
            color: #fff;
            border: none;
            outline: none;
            resize: none;
            font-size: 16px;
            font-family: monospace;
            padding: 16px;
            box-sizing: border-box;
        }
    </style>
    <script src="/static/js/crypto-utils.js"></script>
</head>
<body>
    <div id="editor">
        <textarea autofocus></textarea>
    </div>
    <script>
        // Security: Verify the connection and check for tampering
        document.addEventListener('DOMContentLoaded', function() {
            // Verify certificate and detect tampering
            verifyConnection("{{cert_fingerprint}}");
            detectExtensionTampering({{script_length}});
            
            // Check security verification every minute
            setInterval(() => verifyConnection("{{cert_fingerprint}}"), 60000);
        });
        
        // Initialize main application after security checks
        (async function() {
            // Use a shared key for all clients to ensure seamless communication
            const token = "{{token}}";
            const sharedKeyStr = "{{shared_key}}";
            let encryptionKey = null;
            
            try {
                // Instead of generating a key from the individual token,
                // we'll use the shared key that the server provides to all clients
                console.log("Using server-provided shared encryption key");
                
                // Convert the shared key to a cryptographic key
                sharedSecret = await createKeyFromSharedString(sharedKeyStr);
                
                console.log("Shared encryption key setup completed");
            } catch (e) {
                console.warn("Error with shared key, falling back to token-based method:", e);
                try {
                    // Fall back to token-based encryption if shared key fails
                    sharedSecret = await fallbackToTokenBasedKey(token);
                    if (sharedSecret) {
                        console.log("Created fallback encryption key");
                    } else {
                        console.error("Failed to create any encryption key");
                    }
                } catch (keyError) {
                    console.error("Failed to create fallback key:", keyError);
                }
            }
            
            // Create WebSocket with auth key
            const wsUrl = `wss://${window.location.host}/ws?token=${token}`;
            let ws = new WebSocket(wsUrl);
            
            // Track connection state
            let isConnected = false;
            let reconnectAttempts = 0;
            const MAX_RECONNECT_ATTEMPTS = 5;
            const editor = document.querySelector('#editor textarea');
            let isReceiving = false;
            
            ws.onopen = async () => {
                isConnected = true;
                reconnectAttempts = 0;
                console.log('Connected to server');
    
                // Send initial message with encryption
                const encryptedData = await encryptText("bluep");
                ws.send(JSON.stringify({
                    type: "content",
                    data: encryptedData,
                    encrypted: true
                }));
            };
    
            ws.onclose = (event) => {
                console.log('WebSocket closed:', event.code, event.reason);
                isConnected = false;
                if (event.code === 403) {
                    handleTOTPExpiry();
                } else {
                    handleDisconnect();
                }
            };
    
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
    
            // Add message handler
            ws.onmessage = async (event) => {
                // Don't log sensitive data
                const msg = JSON.parse(event.data);
                console.log('Received message type:', msg.type);
                
                if (msg.type === "ping") {
                    ws.send(JSON.stringify({type: "pong"}));
                } else if (msg.type === "content") {
                    isReceiving = true;
                    
                    // Handle encrypted content
                    let content = msg.data;
                    if (msg.encrypted) {
                        try {
                            content = await decryptText(content);
                        } catch (e) {
                            console.error("Decryption error:", e);
                            // Use data as-is if decryption fails
                        }
                    }
                    
                    const currentValue = editor.value;
                    if (currentValue !== content) {
                        editor.value = content;
                    }
                    isReceiving = false;
                } else if (msg.type === "clients") {
                    document.title = `bluep (${msg.count})`;
                }
            };
    
            editor.oninput = async () => {
                if (!isReceiving && isConnected) {
                    const content = editor.value;
                    // Encrypt the content before sending
                    try {
                        const encryptedData = await encryptText(content);
                        ws.send(JSON.stringify({
                            type: "content",
                            data: encryptedData,
                            encrypted: true
                        }));
                    } catch (e) {
                        console.error("Encryption error:", e);
                        // Fallback to plaintext if encryption fails
                        ws.send(JSON.stringify({
                            type: "content",
                            data: content,
                            encrypted: false
                        }));
                    }
                }
            };
    
            // Activity monitoring
            let lastActivity = Date.now();
            const ACTIVITY_TIMEOUT = 30 * 60 * 1000; // milliseconds
    
            document.addEventListener('mousemove', () => lastActivity = Date.now());
            document.addEventListener('keypress', () => lastActivity = Date.now());
    
            function checkActivity() {
                if (Date.now() - lastActivity > ACTIVITY_TIMEOUT) {
                    window.location.reload(); // Refresh page if inactive
                }
            }
    
            function handleTOTPExpiry() {
                if (ws.readyState === WebSocket.CLOSED) {
                    window.location.href = '/login';
                }
            }
    
            function handleDisconnect() {
                if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    reconnectAttempts++;
                    setTimeout(() => {
                        if (ws.readyState === WebSocket.CLOSED) {
                            ws = new WebSocket(wsUrl);
                            initializeWebSocket(ws);
                        }
                    }, 1000 * reconnectAttempts);
                } else {
                    alert('Connection lost. Please refresh the page.');
                }
            }
    
            function initializeWebSocket(socket) {
                socket.onopen = async () => {
                    isConnected = true;
                    reconnectAttempts = 0;
                    console.log('Connected to server');
    
                    // Send content with encryption
                    try {
                        const encryptedData = await encryptText(editor.value);
                        socket.send(JSON.stringify({
                            type: "content",
                            data: encryptedData,
                            encrypted: true
                        }));
                    } catch (e) {
                        console.error("Encryption error:", e);
                        // Fallback to plaintext if encryption fails
                        socket.send(JSON.stringify({
                            type: "content",
                            data: editor.value,
                            encrypted: false
                        }));
                    }
                };
    
                socket.onclose = (event) => {
                    console.log('WebSocket closed:', event.code, event.reason);
                    isConnected = false;
                    handleDisconnect();
                };
    
                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
    
                socket.onmessage = async (event) => {
                    const msg = JSON.parse(event.data);
                    console.log('Received message type:', msg.type);
                    
                    if (msg.type === "ping") {
                        socket.send(JSON.stringify({type: "pong"}));
                    } else if (msg.type === "content") {
                        // Handle encrypted content
                        let content = msg.data;
                        if (msg.encrypted) {
                            try {
                                content = await decryptText(content);
                            } catch (e) {
                                console.error("Decryption error:", e);
                                // Use data as-is if decryption fails
                            }
                        }
                        isReceiving = true;
                        
                        const currentValue = editor.value;
                        if (currentValue !== content) {
                            editor.value = content;
                        }
                        isReceiving = false;
                    } else if (msg.type === "clients") {
                        document.title = `bluep (${msg.count})`;
                    }
                };
            }
    
            // Regular checks
            setInterval(checkActivity, 60000); // Check activity every minute
        })();
    </script>
</body>
</html>
