<!DOCTYPE html>
<html>
<head>
    <title>bluep (0)</title>
    <link rel="icon" type="image/png" href="/favicon.png?key={{key}}">
    <style>
        body, html {
            margin: 0;
            padding: 8px;
            height: calc(100vh - 32px);
            width: calc(100vw - 32px);
            background: {{blue}};
            overflow: hidden;
        }
        #editor {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 16px;
            background-color: {{blue}};
            color: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
            resize: none;
            box-sizing: border-box;
            position: relative;
        }
        #editor::before {
            content: "bluep";
            position: absolute;
            top: -0.5em;
            left: 3em;
            transform: translateX(-50%);
            background: {{blue}};
            padding: 0 10px;
            color: #fff;
        }
        #editor textarea {
            width: 100%;
            height: 100%;
            background-color: {{blue}};
            color: #fff;
            border: none;
            outline: none;
            resize: none;
            font-size: 16px;
            font-family: monospace;
            padding: 16px;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div id="editor">
        <textarea autofocus></textarea>
    </div>
    <script>
        // Create WebSocket with auth key
        const wsUrl = `wss://${window.location.host}/ws?token={{token}}`;
        let ws = new WebSocket(wsUrl);

        // Track connection state
        let isConnected = false;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;
        const editor = document.querySelector('#editor textarea');
        let isReceiving = false;
        
        // Encryption key - derived from the token plus a fixed salt
        // In a real production system, you would use a more robust key exchange mechanism
        const encryptionKey = "{{token}}salt_bluep_secure";
        
        // Simple encryption/decryption functions using AES from SubtleCrypto
        async function encryptText(text) {
            const encoder = new TextEncoder();
            const data = encoder.encode(text);
            
            // Create a key from the encryption key string
            const keyMaterial = await window.crypto.subtle.importKey(
                "raw",
                encoder.encode(encryptionKey),
                { name: "PBKDF2" },
                false,
                ["deriveBits", "deriveKey"]
            );
            
            // Derive an AES-GCM key
            const key = await window.crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: encoder.encode("bluep_salt"),
                    iterations: 100000,
                    hash: "SHA-256"
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                false,
                ["encrypt", "decrypt"]
            );
            
            // Generate an IV
            const iv = window.crypto.getRandomValues(new Uint8Array(12));
            
            // Encrypt the data
            const encryptedContent = await window.crypto.subtle.encrypt(
                {
                    name: "AES-GCM",
                    iv: iv
                },
                key,
                data
            );
            
            // Combine IV and encrypted content
            const encryptedBuffer = new Uint8Array(iv.byteLength + encryptedContent.byteLength);
            encryptedBuffer.set(iv, 0);
            encryptedBuffer.set(new Uint8Array(encryptedContent), iv.byteLength);
            
            // Convert to base64 for transmission
            return btoa(String.fromCharCode.apply(null, encryptedBuffer));
        }
        
        async function decryptText(encryptedText) {
            try {
                const encoder = new TextEncoder();
                
                // Convert from base64
                const encryptedBuffer = Uint8Array.from(atob(encryptedText), c => c.charCodeAt(0));
                
                // Extract IV and encrypted content
                const iv = encryptedBuffer.slice(0, 12);
                const encryptedContent = encryptedBuffer.slice(12);
                
                // Create a key from the encryption key string
                const keyMaterial = await window.crypto.subtle.importKey(
                    "raw",
                    encoder.encode(encryptionKey),
                    { name: "PBKDF2" },
                    false,
                    ["deriveBits", "deriveKey"]
                );
                
                // Derive an AES-GCM key
                const key = await window.crypto.subtle.deriveKey(
                    {
                        name: "PBKDF2",
                        salt: encoder.encode("bluep_salt"),
                        iterations: 100000,
                        hash: "SHA-256"
                    },
                    keyMaterial,
                    { name: "AES-GCM", length: 256 },
                    false,
                    ["encrypt", "decrypt"]
                );
                
                // Decrypt the data
                const decryptedContent = await window.crypto.subtle.decrypt(
                    {
                        name: "AES-GCM",
                        iv: iv
                    },
                    key,
                    encryptedContent
                );
                
                // Convert to text
                return new TextDecoder().decode(decryptedContent);
            } catch (e) {
                console.error("Decryption error:", e);
                return "Error decrypting message";
            }
        }

        ws.onopen = async () => {
            isConnected = true;
            reconnectAttempts = 0;
            console.log('Connected to server');

            // Send initial message with encrypted content
            const encryptedData = await encryptText("bluep");
            ws.send(JSON.stringify({
                type: "content",
                data: encryptedData,
                encrypted: true
            }));
        };

        ws.onclose = (event) => {
            console.log('WebSocket closed:', event.code, event.reason);
            isConnected = false;
            if (event.code === 403) {
                handleTOTPExpiry();
            } else {
                handleDisconnect();
            }
        };

        ws.onerror = (error) => {
            console.error('WebSocket error:', error);
        };

        // Add message handler
        ws.onmessage = async (event) => {
            // Don't log the full message content as it may contain sensitive data
            console.log('Received message type:', JSON.parse(event.data).type);
            
            const msg = JSON.parse(event.data);
            if (msg.type === "ping") {
                console.log('Received ping, sending pong');
                ws.send(JSON.stringify({type: "pong"}));
            } else if (msg.type === "content") {
                isReceiving = true;
                
                // Handle encrypted content
                let content = msg.data;
                if (msg.encrypted) {
                    try {
                        content = await decryptText(msg.data);
                    } catch (e) {
                        console.error("Failed to decrypt message:", e);
                        content = "Error: Could not decrypt message";
                    }
                }
                
                const currentValue = editor.value;
                if (currentValue !== content) {
                    editor.value = content;
                }
                isReceiving = false;
            } else if (msg.type === "clients") {
                // Don't log client IP information, just update the counter
                document.title = `bluep (${msg.count})`;
            }
        };

        editor.oninput = async () => {
            if (!isReceiving && isConnected) {
                const content = editor.value;
                // Encrypt the content before sending
                const encryptedData = await encryptText(content);
                ws.send(JSON.stringify({
                    type: "content",
                    data: encryptedData,
                    encrypted: true
                }));
            }
        };

        // Activity monitoring
        let lastActivity = Date.now();
        const ACTIVITY_TIMEOUT = 30 * 60 * 1000; // milliseconds

        document.addEventListener('mousemove', () => lastActivity = Date.now());
        document.addEventListener('keypress', () => lastActivity = Date.now());

        function checkActivity() {
            if (Date.now() - lastActivity > ACTIVITY_TIMEOUT) {
                window.location.reload(); // Refresh page if inactive
            }
        }

        function handleTOTPExpiry() {
            if (ws.readyState === WebSocket.CLOSED) {
                window.location.href = '/login';
            }
        }

        function handleDisconnect() {
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                reconnectAttempts++;
                setTimeout(() => {
                    if (ws.readyState === WebSocket.CLOSED) {
                        ws = new WebSocket(wsUrl);
                        initializeWebSocket(ws);
                    }
                }, 1000 * reconnectAttempts);
            } else {
                alert('Connection lost. Please refresh the page.');
            }
        }

        function initializeWebSocket(socket) {
            socket.onopen = async () => {
                isConnected = true;
                reconnectAttempts = 0;
                console.log('Connected to server');

                // Encrypt content before sending
                const encryptedData = await encryptText(editor.value);
                socket.send(JSON.stringify({
                    type: "content",
                    data: encryptedData,
                    encrypted: true
                }));
            };

            socket.onclose = (event) => {
                console.log('WebSocket closed:', event.code, event.reason);
                isConnected = false;
                handleDisconnect();
            };

            socket.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

            socket.onmessage = async (event) => {
                // Don't log the full message content as it may contain sensitive data
                console.log('Received message type:', JSON.parse(event.data).type);
                
                const msg = JSON.parse(event.data);
                if (msg.type === "ping") {
                    console.log('Received ping, sending pong');
                    socket.send(JSON.stringify({type: "pong"}));
                } else if (msg.type === "content") {
                    isReceiving = true;
                    
                    // Handle encrypted content
                    let content = msg.data;
                    if (msg.encrypted) {
                        try {
                            content = await decryptText(msg.data);
                        } catch (e) {
                            console.error("Failed to decrypt message:", e);
                            content = "Error: Could not decrypt message";
                        }
                    }
                    
                    const currentValue = editor.value;
                    if (currentValue !== content) {
                        editor.value = content;
                    }
                    isReceiving = false;
                } else if (msg.type === "clients") {
                    // Don't log client IP information, just update the counter
                    document.title = `bluep (${msg.count})`;
                }
            };
        }

        // Regular checks
        setInterval(checkActivity, 60000); // Check activity every minute
    </script>
</body>
</html>
