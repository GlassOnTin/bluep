<!DOCTYPE html>
<html>
<head>
    <title>bluep terminal</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="stylesheet" href="/static/js/lib/xterm.css">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            background: #1a1a2e;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }
        
        #terminal-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0f0f23;
            margin: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }
        
        #terminal-header {
            background: #16213e;
            padding: 10px 15px;
            color: #fff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #2a2a4e;
        }
        
        #terminal-tabs {
            display: flex;
            gap: 5px;
        }
        
        .terminal-tab {
            padding: 5px 15px;
            background: #1a1a2e;
            color: #aaa;
            border-radius: 5px 5px 0 0;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .terminal-tab.active {
            background: #0f0f23;
            color: #fff;
        }
        
        .terminal-tab:hover {
            background: #2a2a4e;
        }
        
        .terminal-tab .close-btn {
            font-size: 12px;
            opacity: 0.6;
            transition: opacity 0.2s;
        }
        
        .terminal-tab .close-btn:hover {
            opacity: 1;
        }
        
        #new-terminal-btn {
            padding: 5px 10px;
            background: #2a2a4e;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        #new-terminal-btn:hover {
            background: #3a3a5e;
        }
        
        #terminal-output {
            flex: 1;
            padding: 10px;
            background: #0f0f23;
            overflow: hidden;
            position: relative;
        }
        
        .terminal-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
        }
        
        .terminal-container.active {
            display: block;
        }
        
        
        #command-selector {
            margin: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .command-btn {
            padding: 8px 16px;
            background: #2a2a4e;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        
        .command-btn:hover {
            background: #3a3a5e;
            transform: translateY(-1px);
        }
        
        .command-btn.active {
            background: #4fc3f7;
            color: #0f0f23;
        }
        
        
        /* Scrollbar styling */
        #terminal-output::-webkit-scrollbar {
            width: 8px;
        }
        
        #terminal-output::-webkit-scrollbar-track {
            background: #16213e;
        }
        
        #terminal-output::-webkit-scrollbar-thumb {
            background: #2a2a4e;
            border-radius: 4px;
        }
        
        #terminal-output::-webkit-scrollbar-thumb:hover {
            background: #3a3a5e;
        }
    </style>
    <script src="/static/js/crypto-utils.js"></script>
    <script src="/static/js/lib/xterm.min.js"></script>
    <script src="/static/js/lib/xterm-addon-fit.min.js"></script>
</head>
<body>
    <div id="command-selector">
        <button class="command-btn" data-command="bash">Bash</button>
        <button class="command-btn" data-command="python">Python</button>
        <button class="command-btn" data-command="node">Node.js</button>
        <button class="command-btn" data-command="claude">Claude</button>
    </div>
    
    <div id="terminal-container">
        <div id="terminal-header">
            <div id="terminal-tabs"></div>
            <button id="new-terminal-btn">+ New Terminal</button>
        </div>
        <div id="terminal-output"></div>
    </div>
    
    <script>
        // Terminal state
        let terminals = {};
        let activeTerminalId = null;
        let ws = null;
        let isConnected = false;
        const token = "{{token}}";
        const sharedKeyStr = "{{shared_key}}";
        let encryptionKey = null;
        let switchingTerminal = false;
        let focusTimeout = null;
        let messageQueue = [];
        let processingMessages = false;
        let lastMessageTime = Date.now();
        
        // Debug helpers
        window.terminals = terminals;
        window.activeTerminalId = () => activeTerminalId;
        window.ws = () => ws;
        window.messageQueue = messageQueue;
        
        // Keyboard shortcut for diagnostics (Ctrl+Shift+D)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                console.log('=== TERMINAL DEBUG STATE ===');
                console.log('Active Terminal ID:', activeTerminalId);
                console.log('Switching Terminal:', switchingTerminal);
                console.log('Processing Messages:', processingMessages);
                console.log('WebSocket State:', ws ? ws.readyState : 'null');
                console.log('Message Queue Length:', messageQueue.length);
                console.log('Terminals:', Object.keys(terminals).map(id => ({
                    id: id.substring(0, 8),
                    active: terminals[id].active,
                    terminating: terminals[id].terminating,
                    hasContainer: !!terminals[id].container,
                    containerInDOM: terminals[id].container && document.body.contains(terminals[id].container)
                })));
                console.log('Active Element:', document.activeElement);
                console.log('=========================');
            }
            
            // Emergency reset (Ctrl+Shift+R)
            if (e.ctrlKey && e.shiftKey && e.key === 'R') {
                e.preventDefault();
                console.warn('EMERGENCY RESET - Forcing state reset');
                switchingTerminal = false;
                processingMessages = false;
                window.switchingTerminal = false;
                
                // Try to focus active terminal
                if (activeTerminalId && terminals[activeTerminalId]) {
                    terminals[activeTerminalId].terminal.focus();
                }
                console.log('Reset complete');
            }
        });
        
        // xterm.js configuration
        const terminalOptions = {
            cursorBlink: true,
            fontSize: 14,
            fontFamily: 'Monaco, Menlo, "Ubuntu Mono", monospace',
            theme: {
                background: '#0f0f23',
                foreground: '#e8e8e8',
                cursor: '#4fc3f7',
                selection: 'rgba(79, 195, 247, 0.3)',
                black: '#000000',
                red: '#cd3131',
                green: '#0dbc79',
                yellow: '#e5e510',
                blue: '#2472c8',
                magenta: '#bc3fbc',
                cyan: '#11a8cd',
                white: '#e5e5e5',
                brightBlack: '#666666',
                brightRed: '#f14c4c',
                brightGreen: '#23d18b',
                brightYellow: '#f5f543',
                brightBlue: '#3b8eea',
                brightMagenta: '#d670d6',
                brightCyan: '#29b8db',
                brightWhite: '#ffffff'
            }
        };
        
        // Initialize encryption
        (async function() {
            try {
                sharedSecret = await createKeyFromSharedString(sharedKeyStr);
                console.log("Shared encryption key setup completed");
            } catch (e) {
                console.warn("Error with shared key:", e);
                sharedSecret = await fallbackToTokenBasedKey(token);
            }
            
            // Initialize WebSocket
            initializeWebSocket();
        })();
        
        function initializeWebSocket() {
            // Don't create new connection if one already exists
            if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
                console.log('WebSocket already exists in state:', ws.readyState);
                return;
            }
            
            const wsUrl = `wss://${window.location.host}/ws?token=${encodeURIComponent(token)}`;
            console.log('Connecting to WebSocket:', wsUrl);
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                isConnected = true;
                console.log('Connected to server');
                
                // Clear message queue
                messageQueue = [];
                processingMessages = false;
                
                // Request process list immediately
                console.log('Requesting process list');
                try {
                    ws.send(JSON.stringify({ type: "process-list" }));
                } catch (e) {
                    console.error('Error requesting process list:', e);
                }
            };
            
            ws.onclose = (event) => {
                console.error('WebSocket closed unexpectedly:', event.code, event.reason, event);
                console.trace('WebSocket close stack trace');
                isConnected = false;
                
                // Don't mark terminals as inactive on disconnect - they might still be running
                // Just update the visual state
                for (const processId in terminals) {
                    if (terminals[processId]) {
                        updateTerminalTab(processId);
                    }
                }
                
                if (event.code === 403) {
                    window.location.href = '/login';
                } else if (event.code !== 1000 && event.code !== 1001) {
                    // Try to reconnect for abnormal closures
                    showError(`WebSocket disconnected (${event.code}). Trying to reconnect...`);
                    setTimeout(() => {
                        console.log('Attempting to reconnect WebSocket...');
                        initializeWebSocket();
                    }, 2000);
                }
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
            
            ws.onmessage = async (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    console.log('Received message type:', msg.type);
                    lastMessageTime = Date.now();
                    
                    // Queue message for processing
                    messageQueue.push(msg);
                    // Process queue asynchronously to avoid blocking
                    setTimeout(() => processMessageQueue(), 0);
                } catch (e) {
                    console.error('Error parsing WebSocket message:', e);
                    console.error('Raw message:', event.data);
                }
            };
        }
        
        // Process messages from queue to prevent blocking
        async function processMessageQueue() {
            if (processingMessages || messageQueue.length === 0) {
                return;
            }
            
            processingMessages = true;
            console.log(`Processing ${messageQueue.length} queued messages`);
            
            try {
                while (messageQueue.length > 0) {
                    const msg = messageQueue.shift();
                    console.log(`Processing message: ${msg.type}`);
                    
                    if (msg.type === "ping") {
                        console.log('Received ping, sending pong...');
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            try {
                                ws.send(JSON.stringify({type: "pong"}));
                                console.log('Pong sent successfully');
                            } catch (e) {
                                console.error('Error sending pong:', e);
                            }
                        } else {
                            console.error('Cannot send pong - WebSocket not open:', ws.readyState);
                        }
                    } else if (msg.type === "process-status") {
                        await handleProcessStatus(msg);
                    } else if (msg.type === "process-output") {
                        await handleProcessOutput(msg);
                    } else if (msg.type === "process-list") {
                        await handleProcessList(msg);
                    } else if (msg.type === "error") {
                        const errorMsg = msg.error || 'Unknown error occurred';
                        console.error('Server error:', errorMsg);
                        showError(errorMsg);
                    } else if (msg.type === "content") {
                        // Handle content message (ignore for terminal)
                        console.log('Ignoring content message in terminal');
                    } else if (msg.type === "clients") {
                        // Handle clients message (ignore for terminal)
                        console.log(`Clients connected: ${msg.count}`);
                    } else {
                        console.warn(`Unknown message type: ${msg.type}`);
                    }
                    
                    // Yield to prevent blocking
                    if (messageQueue.length > 10) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }
            } catch (e) {
                console.error('Error processing message queue:', e);
            } finally {
                processingMessages = false;
                // Check if more messages arrived while processing
                if (messageQueue.length > 0) {
                    setTimeout(() => processMessageQueue(), 0);
                }
            }
        }
        
        // Monitor connection health
        setInterval(() => {
            const now = Date.now();
            if (isConnected && (now - lastMessageTime) > 60000) {
                console.warn('No messages received for 60 seconds, connection may be stale');
                // Only reconnect if the WebSocket is actually closed
                if (ws.readyState !== WebSocket.OPEN && ws.readyState !== WebSocket.CONNECTING) {
                    console.log('WebSocket is closed, attempting to reconnect');
                    setTimeout(() => initializeWebSocket(), 1000);
                }
            }
        }, 10000);
        
        // Command selector
        document.querySelectorAll('.command-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const command = btn.dataset.command;
                spawnTerminal(command);
                
                // Update active button
                document.querySelectorAll('.command-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });
        
        // New terminal button
        document.getElementById('new-terminal-btn').addEventListener('click', () => {
            const activeBtn = document.querySelector('.command-btn.active');
            const command = activeBtn ? activeBtn.dataset.command : 'bash';
            spawnTerminal(command);
        });
        
        // Terminal output element
        const terminalOutput = document.getElementById('terminal-output');
        
        // Spawn a new terminal
        function spawnTerminal(command) {
            if (!isConnected || !ws || ws.readyState !== WebSocket.OPEN) {
                showError("Not connected to server");
                return;
            }
            
            try {
                ws.send(JSON.stringify({
                    type: "process-spawn",
                    command: command
                }));
            } catch (e) {
                console.error('Error spawning terminal:', e);
                showError('Failed to spawn terminal');
            }
        }
        
        // Handle process status updates
        async function handleProcessStatus(msg) {
            const { processId, status, command } = msg;
            
            if (status === "spawned") {
                // Create xterm.js terminal instance
                const term = new Terminal(terminalOptions);
                const fitAddon = new FitAddon.FitAddon();
                term.loadAddon(fitAddon);
                
                // Create a container div for this terminal
                const container = document.createElement('div');
                container.className = 'terminal-container';
                container.dataset.processId = processId;
                terminalOutput.appendChild(container);
                
                terminals[processId] = {
                    id: processId,
                    command: command,
                    terminal: term,
                    fitAddon: fitAddon,
                    container: container,
                    active: true,
                    bufferedOutput: [],  // Initialize buffer for when terminal is inactive
                    dataDisposable: null,  // Will store the disposable for cleanup
                    terminating: false,  // Track if terminal is being terminated
                    readyForCleanup: false  // Track if terminal is ready to be cleaned up
                };
                
                // Handle terminal input - use a closure-safe function
                // Store the disposable so we can clean it up later
                terminals[processId].dataDisposable = term.onData((function(pid) {
                    return function(data) {
                        // Check activeTerminalId at the time of input, not creation
                        if (isConnected && ws && ws.readyState === WebSocket.OPEN && 
                            activeTerminalId === pid && terminals[pid] && terminals[pid].active) {
                            try {
                                console.log(`Sending input for terminal ${pid}: ${data.charCodeAt(0)}`);
                                ws.send(JSON.stringify({
                                    type: "process-input",
                                    processId: pid,
                                    data: data
                                }));
                            } catch (e) {
                                console.error('Error sending process input:', e);
                                terminals[pid].terminal.write('\r\n[Error: Connection lost]\r\n');
                            }
                        } else if (terminals[pid] && !terminals[pid].active) {
                            // Show message for inactive terminals
                            terminals[pid].terminal.write('\r\n[Terminal is inactive - read only]\r\n');
                        }
                    };
                })(processId));
                
                createTerminalTab(processId, command);
                switchToTerminal(processId);
                
                // Fit terminal and send size
                setTimeout(() => {
                    try {
                        fitAddon.fit();
                        const dims = fitAddon.proposeDimensions();
                        if (dims && ws && ws.readyState === WebSocket.OPEN && isConnected) {
                            ws.send(JSON.stringify({
                                type: "process-resize",
                                processId: processId,
                                cols: dims.cols,
                                rows: dims.rows
                            }));
                        }
                    } catch (e) {
                        console.error('Error fitting terminal:', e);
                    }
                }, 100);
            } else if (status === "exited" || status === "terminated") {
                // Mark terminal as inactive
                if (terminals[processId]) {
                    terminals[processId].active = false;
                    terminals[processId].terminating = false;  // Reset terminating flag
                    updateTerminalTab(processId);
                    terminals[processId].terminal.write(`\r\n[Process ${status}]\r\n`);
                    console.log(`Terminal ${processId} marked as ${status}, terminating flag reset`);
                    
                    // Auto-close terminal after showing status
                    setTimeout(() => {
                        // Mark terminal as ready for cleanup
                        if (terminals[processId]) {
                            terminals[processId].readyForCleanup = true;
                        }
                        
                        // If this was the active terminal, switch to another first
                        if (activeTerminalId === processId) {
                            const remainingIds = Object.keys(terminals).filter(id => 
                                id !== processId && 
                                terminals[id] && 
                                terminals[id].active && 
                                !terminals[id].terminating
                            );
                            if (remainingIds.length > 0) {
                                // Reset switching flag to ensure we can switch
                                switchingTerminal = false;
                                // Switch to another terminal, cleanup will happen after switch completes
                                switchToTerminal(remainingIds[0]);
                            } else {
                                // Only set to null if no other terminals exist
                                activeTerminalId = null;
                                switchingTerminal = false;
                                // No other terminals, safe to cleanup immediately
                                cleanupTerminal(processId);
                            }
                        } else {
                            // Not active terminal, safe to cleanup
                            cleanupTerminal(processId);
                        }
                    }, 2000);  // Wait 2 seconds before cleaning up
                }
            }
        }
        
        // Handle process output
        async function handleProcessOutput(msg) {
            const { processId, outputData } = msg;
            
            if (!outputData || !terminals[processId]) return;
            
            try {
                // Only write to terminal if it's the active one to reduce load
                if (processId === activeTerminalId) {
                    // Decode base64 output and write directly to xterm
                    const decoded = atob(outputData);
                    terminals[processId].terminal.write(new Uint8Array(
                        [...decoded].map(c => c.charCodeAt(0))
                    ));
                } else {
                    // Buffer output for inactive terminals
                    if (!terminals[processId].bufferedOutput) {
                        terminals[processId].bufferedOutput = [];
                    }
                    terminals[processId].bufferedOutput.push(outputData);
                    
                    // Limit buffer size to prevent memory issues
                    if (terminals[processId].bufferedOutput.length > 100) {
                        terminals[processId].bufferedOutput.shift();
                    }
                }
            } catch (e) {
                console.error("Failed to decode output:", e);
            }
        }
        
        // Handle process list
        async function handleProcessList(msg) {
            const { processes } = msg;
            
            if (!processes || processes.length === 0) return;
            
            console.log(`Received process list with ${processes.length} processes`);
            
            // Restore existing terminals
            processes.forEach(proc => {
                if (!terminals[proc.process_id]) {
                    console.log(`Creating terminal for process ${proc.process_id}`);
                    // Create xterm.js terminal for existing process
                    const term = new Terminal(terminalOptions);
                    const fitAddon = new FitAddon.FitAddon();
                    term.loadAddon(fitAddon);
                    
                    // Create a container div for this terminal
                    const container = document.createElement('div');
                    container.className = 'terminal-container';
                    container.dataset.processId = proc.process_id;
                    terminalOutput.appendChild(container);
                    
                    terminals[proc.process_id] = {
                        id: proc.process_id,
                        command: proc.command,
                        terminal: term,
                        fitAddon: fitAddon,
                        container: container,
                        active: proc.is_alive,
                        bufferedOutput: [],
                        dataDisposable: null,
                        terminating: false,
                        readyForCleanup: false
                    };
                    
                    // Handle terminal input - use a closure-safe function
                    // Store the disposable so we can clean it up later
                    terminals[proc.process_id].dataDisposable = term.onData((function(pid) {
                        return function(data) {
                            // Check activeTerminalId at the time of input, not creation
                            if (isConnected && ws && ws.readyState === WebSocket.OPEN && 
                                activeTerminalId === pid && terminals[pid] && terminals[pid].active) {
                                try {
                                    console.log(`Sending input for terminal ${pid}: ${data.charCodeAt(0)}`);
                                    ws.send(JSON.stringify({
                                        type: "process-input",
                                        processId: pid,
                                        data: data
                                    }));
                                } catch (e) {
                                    console.error('Error sending process input:', e);
                                    if (terminals[pid]) {
                                        terminals[pid].terminal.write('\r\n[Error: Connection lost]\r\n');
                                    }
                                }
                            }
                        };
                    })(proc.process_id));
                    
                    createTerminalTab(proc.process_id, proc.command);
                }
            });
            
            // Activate first terminal if none active
            if (!activeTerminalId && Object.keys(terminals).length > 0) {
                // Delay to ensure DOM is ready
                setTimeout(() => {
                    switchToTerminal(Object.keys(terminals)[0]);
                }, 200);
            }
        }
        
        // Create terminal tab
        function createTerminalTab(processId, command) {
            const tabsContainer = document.getElementById('terminal-tabs');
            
            const tab = document.createElement('div');
            tab.className = 'terminal-tab';
            tab.dataset.processId = processId;
            tab.innerHTML = `
                <span>${command}</span>
                <span class="close-btn">×</span>
            `;
            
            tab.addEventListener('click', (e) => {
                e.stopPropagation();
                if (e.target.classList.contains('close-btn')) {
                    // Allow closing inactive terminals directly
                    if (terminals[processId] && !terminals[processId].active) {
                        // If this was the active terminal, switch to another first
                        if (activeTerminalId === processId) {
                            const remainingIds = Object.keys(terminals).filter(id => 
                                id !== processId && 
                                terminals[id] && 
                                terminals[id].active && 
                                !terminals[id].terminating
                            );
                            if (remainingIds.length > 0) {
                                switchToTerminal(remainingIds[0]);
                            } else {
                                // Only set to null if no other terminals exist
                                activeTerminalId = null;
                            }
                        }
                        // Clean up terminal resources
                        cleanupTerminal(processId);
                    } else {
                        // For active terminals, send terminate command
                        terminateProcess(processId);
                    }
                } else {
                    console.log(`Tab click switching to terminal ${processId}`);
                    switchToTerminal(processId);
                }
            });
            
            tabsContainer.appendChild(tab);
        }
        
        // Update terminal tab appearance
        function updateTerminalTab(processId) {
            const tab = document.querySelector(`.terminal-tab[data-process-id="${processId}"]`);
            if (tab && terminals[processId] && !terminals[processId].active) {
                tab.style.opacity = '0.6';
            }
        }
        
        // Switch to a terminal
        function switchToTerminal(processId) {
            if (!terminals[processId]) return;
            
            // Prevent rapid switching
            if (switchingTerminal) {
                console.log('Already switching terminals, ignoring request');
                return;
            }
            
            // Don't switch if already active
            if (activeTerminalId === processId) {
                return;
            }
            
            // Don't switch to terminals that are being terminated
            if (terminals[processId].terminating) {
                console.log(`Cannot switch to terminating terminal ${processId}`);
                // Try to find another active terminal
                const alternativeIds = Object.keys(terminals).filter(id => 
                    id !== processId && 
                    terminals[id] && 
                    terminals[id].active && 
                    !terminals[id].terminating
                );
                if (alternativeIds.length > 0) {
                    console.log(`Switching to alternative terminal ${alternativeIds[0]}`);
                    switchToTerminal(alternativeIds[0]);
                }
                return;
            }
            
            // Allow switching to view inactive terminals (read-only)
            // Just skip the active check - inactive terminals can be viewed
            
            if (activeTerminalId !== null) {
                console.log(`Switching from terminal ${activeTerminalId} to ${processId}`);
            } else {
                console.log(`Activating terminal ${processId} (no previous active terminal)`);
            }
            switchingTerminal = true;
            
            // Ensure we always reset the flag after a reasonable timeout
            setTimeout(() => {
                if (switchingTerminal) {
                    console.warn('Forcing switchingTerminal reset after timeout');
                    switchingTerminal = false;
                }
            }, 1000);
            
            // Clear any pending focus operations
            if (focusTimeout) {
                clearTimeout(focusTimeout);
                focusTimeout = null;
            }
            
            // Store the target terminal ID to detect if it changes during async operations
            const targetTerminalId = processId;
            
            // Blur the current terminal first
            if (activeTerminalId && terminals[activeTerminalId]) {
                terminals[activeTerminalId].terminal.blur();
            }
            
            // Hide all terminal containers except the one we're switching to
            document.querySelectorAll('.terminal-container').forEach(container => {
                container.classList.remove('active');
            });
            
            // Blur all terminals
            Object.entries(terminals).forEach(([id, term]) => {
                if (id !== processId) {
                    term.terminal.blur();
                }
            });
            
            activeTerminalId = processId;
            const terminal = terminals[processId];
            
            // Update tab appearance
            document.querySelectorAll('.terminal-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            const activeTab = document.querySelector(`.terminal-tab[data-process-id="${processId}"]`);
            if (activeTab) {
                activeTab.classList.add('active');
            }
            
            // Show the terminal container
            terminal.container.classList.add('active');
            
            // Open terminal in its container if not already opened
            if (!terminal.terminal.element || !terminal.terminal.element.parentNode) {
                terminal.terminal.open(terminal.container);
            }
            
            // Fit terminal to container and focus with proper delay
            focusTimeout = setTimeout(() => {
                // Check if we're still switching to the same terminal
                if (activeTerminalId !== targetTerminalId) {
                    console.log(`Terminal switch cancelled - activeTerminalId changed`);
                    switchingTerminal = false;
                    return;
                }
                
                // Fit the terminal and force a refresh
                terminal.fitAddon.fit();
                terminal.terminal.refresh(0, terminal.terminal.rows - 1);
                
                // Flush any buffered output for this terminal
                if (terminal.bufferedOutput && terminal.bufferedOutput.length > 0) {
                    console.log(`Flushing ${terminal.bufferedOutput.length} buffered outputs`);
                    try {
                        for (const outputData of terminal.bufferedOutput) {
                            const decoded = atob(outputData);
                            terminal.terminal.write(new Uint8Array(
                                [...decoded].map(c => c.charCodeAt(0))
                            ));
                        }
                        terminal.bufferedOutput = [];
                    } catch (e) {
                        console.error('Error flushing buffered output:', e);
                    }
                }
                
                // Ensure terminal is ready before focusing
                requestAnimationFrame(() => {
                    // Final check before focusing
                    if (activeTerminalId === targetTerminalId && terminals[targetTerminalId]) {
                        // Only focus if terminal is active
                        if (terminal.active) {
                            // Ensure the terminal is properly focused
                            terminal.terminal.focus();
                            console.log(`Terminal ${processId} focused`);
                            
                            // Force focus on the textarea element if it exists
                            if (terminal.terminal.textarea) {
                                terminal.terminal.textarea.focus();
                            }
                            
                            // Test if terminal is actually accepting input
                            setTimeout(() => {
                                if (terminal.terminal.textarea) {
                                    console.log(`Terminal ${processId} textarea state:`, {
                                        exists: !!terminal.terminal.textarea,
                                        focused: document.activeElement === terminal.terminal.textarea,
                                        disabled: terminal.terminal.textarea.disabled,
                                        readOnly: terminal.terminal.textarea.readOnly
                                    });
                                    
                                    // If not focused, try to force focus again
                                    if (document.activeElement !== terminal.terminal.textarea) {
                                        console.log(`Forcing focus on terminal ${processId} textarea`);
                                        terminal.terminal.textarea.focus();
                                    }
                                }
                            }, 100);
                        } else {
                            console.log(`Terminal ${processId} displayed (inactive)`);
                        }
                    }
                    switchingTerminal = false;
                    
                    // Check if there are any terminals waiting for cleanup
                    Object.entries(terminals).forEach(([id, term]) => {
                        if (term.readyForCleanup && id !== activeTerminalId) {
                            console.log(`Cleaning up terminal ${id} after switch completed`);
                            cleanupTerminal(id);
                        }
                    });
                });
            }, 150);
        }
        
        
        // Clean up terminal resources
        function cleanupTerminal(processId) {
            const terminal = terminals[processId];
            if (!terminal) return;
            
            // Don't clean up if we're in the middle of switching to this specific terminal
            if (switchingTerminal && activeTerminalId === processId) {
                console.log(`Deferring cleanup of ${processId} - currently switching to it`);
                setTimeout(() => cleanupTerminal(processId), 1000);
                return;
            }
            
            // Dispose of event handlers
            if (terminal.dataDisposable) {
                terminal.dataDisposable.dispose();
            }
            
            // Clear buffered output
            terminal.bufferedOutput = [];
            
            // Blur and dispose terminal
            try {
                terminal.terminal.blur();
                terminal.terminal.dispose();
            } catch (e) {
                console.error('Error disposing terminal:', e);
            }
            
            // Remove container from DOM
            if (terminal.container && terminal.container.parentNode) {
                terminal.container.parentNode.removeChild(terminal.container);
            }
            
            // Clean up tab
            const tab = document.querySelector(`.terminal-tab[data-process-id="${processId}"]`);
            if (tab) {
                tab.remove();
            }
            
            delete terminals[processId];
        }
        
        // Terminate a process
        function terminateProcess(processId) {
            if (!isConnected || !ws || ws.readyState !== WebSocket.OPEN) {
                console.warn('Cannot terminate process - WebSocket not connected');
                return;
            }
            
            // Only send terminate command if process is still active
            if (terminals[processId] && terminals[processId].active && !terminals[processId].terminating) {
                try {
                    ws.send(JSON.stringify({
                        type: "process-terminate",
                        processId: processId
                    }));
                    
                    // Mark as terminating to prevent duplicate requests
                    terminals[processId].terminating = true;
                    terminals[processId].terminal.write('\r\n[Terminating...]\r\n');
                    console.log(`Terminal ${processId} marked as terminating`);
                } catch (e) {
                    console.error('Error sending terminate command:', e);
                    showError('Failed to terminate process');
                }
            }
            
            // Don't remove tab or terminal here - let the process status handler do it
            // when it receives the "terminated" status. This prevents race conditions
            // with pending output or status messages that might cause WebSocket errors.
        }
        
        
        // Show error message
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                background: #f44336;
                color: white;
                padding: 15px 20px;
                border-radius: 5px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                z-index: 1000;
            `;
            errorDiv.textContent = message;
            document.body.appendChild(errorDiv);
            
            setTimeout(() => {
                document.body.removeChild(errorDiv);
            }, 5000);
        }
        
        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                // Terminate all active processes before closing
                for (const processId in terminals) {
                    if (terminals[processId] && terminals[processId].active) {
                        ws.send(JSON.stringify({
                            type: "process-terminate",
                            processId: processId
                        }));
                    }
                }
                ws.close(1000, 'Page unload');
            }
        });
        
        
        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (activeTerminalId && isConnected && ws && ws.readyState === WebSocket.OPEN && 
                    terminals[activeTerminalId]) {
                    try {
                        const terminal = terminals[activeTerminalId];
                        terminal.fitAddon.fit();
                        const dims = terminal.fitAddon.proposeDimensions();
                        if (dims) {
                            ws.send(JSON.stringify({
                                type: "process-resize",
                                processId: activeTerminalId,
                                cols: dims.cols,
                                rows: dims.rows
                            }));
                        }
                    } catch (e) {
                        console.error('Error resizing terminal:', e);
                    }
                }
            }, 300);
        });
    </script>
</body>
</html>